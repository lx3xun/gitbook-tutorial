{"./":{"url":"./","title":"简介","keywords":"","body":"介绍 一个高效的开发团队包括四个要素：人、过程、技术和团队文化。一群靠谱的人、一套行之有效的团队过程和所采用的实用技术与工具，这三者构成了高效团队的三驾马车，也是团队管理中最为传统的三要素。一个高效的团队更是要具备赢的理念、及时交付的习惯以及达成卓越目标的能力，这是团队久而久之形成的团队文化，团队文化是高效团队的第四个要素。 程序员需谨记的团队开发原则 1. 提交代码需要填写备注说明 团队开发中必定会使用一些类似 svn 的代码管理工具，在提交代码时填写备注，这个好处是不言而喻的。它可以帮你记录这次修改完成了哪些功能、修复了哪些 bug，包括的团队的其他成员，也可以看到你这次提交代码所做的贡献。 2. 对一些公共库的修改一定要谨慎，并且测试再测试 有时候我们并没有修改自己写的代码块，但发现一段时间后，自己的代码编译不了了，于是你很惊讶的发现，代码中调用的公共库接口被修改了。这样的问题相信大家经常遇到，所以当你需要修改公共类库时，一定要非常谨慎，最好在修改完后进行全面的单元测试，或者通知你团队中的每一个成员。 3. 需求要确认，切勿盲目编码 很多的问题其实改起来并不麻烦，但是如果要是因为理解的不一致造成的改来改去，这个是最折磨人的，所以，必须双方都完全确认后，再动手！切忌不要擅作主张。 4. 经常主动地去和别人进行 Code Review 有很多我们固有的不良编码习惯，或者一些我们不熟悉的内容，这些都是我们很难观察到，但我们的同伴可能一眼就能看到的地方，有交互才会有学习，多去理解和学习同伴的好的编码习惯和思考方式，对我们来说这是最容易的一个途径。 5. 要相信自己的工作在团队中是举足轻重的 有了这样的信念，你就会对你的任务更加重视，更全力地去完成它，而不会像其他人一样老是项目延时，这对你在项目中建立信心至关重要。 6. 不要盲目拷贝代码 这一点我想很少有程序员能够做到，无论是从网上的搜索结果还是团队中其他成员编写的代码，即便它们能完成你想要的功能，也不要直接全部复制过来。因为这不仅让你失去了思考问题的能力，而且也有可能引入一些不必要的问题。虽然重复造轮子的做法不可取，但是在你拷贝代码的时候是否也需要思考一下代码的实现思路，这对你的提高非常有用。 7. 及时记录工作日志 这点也很少会有程序员能够做到，“一个没有博客的程序员不是好程序员！”，用博客记录自己开发过程中的经验教训，时间久了，这也是一笔巨大的财富。另外，你分享的这些经验教训，也许还可以帮到别的开发者，或者你团队中的小伙伴。 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"basic/gitbook.html":{"url":"basic/gitbook.html","title":"GitBook使用","keywords":"","body":"GitBook的使用 环境准备 gitbook 的安装非常简单，详细指南可以参考 gitbook 文档。 这里的安装只需要一步就能完成！ $ npm install gitbook gitbook-cli -g 需要注意的是：用户首先需要安装 nodejs，以便能够使用 npm 来安装 gitbook。 gitbook用法 gitbook 的基本用法非常简单，基本上就只有三步： 使用 gitbook install 来安装项目依赖 使用 gitbook init 初始化书籍目录，它会为我们创建 SUMMARY.md 中的文件夹及对应文件。 使用 gitbook serve 编译和预览书籍 $ gitbook serve Press CTRL+C to quit ... Live reload server started on port: 35729 Starting build ... Successfully built! Starting server ... Serving book on http://localhost:4000 目录介绍 README.md 和 SUMMARY.md 是两个必须文件 / ├── README.md // 书籍的简单介绍 └── SUMMARY.md // 书籍的目录结构 SUMMARY.md 是书籍的目录结构。内容如下： # Summary ## 简介 * [简介](README.md) ## 快速上手 * [GitBook使用](basic/gitbook.md) * [Markdown](basic/markdown.md) * [文档编写](basic/document.md) * [持续集成](basic/building.md) ## 前端规范 * [基本原则](front/principle.md) * [开发工具](front/devtool.md) * [HTML](front/html.md) * [通用约定](front/html/general.md) * [语义化](front/html/semantization.md) * [HEAD](front/html/head.md) * [CSS](front/css.md) * [JavaScript](front/javascript.md) * [Vue](front/vue.md) * [ES6](front/es6-style-guide.md) 文档编写使用MarkDown，请查看下步。 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"basic/markdown.html":{"url":"basic/markdown.html","title":"Markdown","keywords":"","body":"Markdown Markdown 是一种轻量级标记语言，它用简洁的语法代替排版，使我们专心于码字。 它的目标是实现易读易写，成为一种适用于网络的书写语言。同时，Markdown支持嵌入html标签。 注意：Markdown使用#、+、*等符号来标记， 符号后面必须跟上 至少1个 空格才有效！ 工欲善其事，必先利其器 MarkDown可选编辑器： Sublime text 3 插件： Package Control（插件依赖库） MarkdownEditing Table Editor (借助Table Editor插件可以方便的插入表格) 如何使用？ Visual Studio Code MarkDown基本语法 目录 标题 列表 引用 强调 转义 图片与链接 代码 分隔线 换行 脚注(注解) 表格 标题 用#标记，在 标题开头 加上1~6个#，依次代表一级标题、二级标题....六级标题 # 一级标题 ## 二级标题 ### 三级标题 ##### 四级标题 ###### 五级标题 ###### 六级标题 效果如下： 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 ↑ 回到目录 列表 Markdown 支持有序列表和无序列表。 无序列表使用-、+和*作为列表标记： - Red * Green + Blue 效果如下： Red Green Blue 有序列表则使用数字加英文句点.来表示： 1. Red 2. Green 3. Blue 效果如下： Red Green Blue 列表嵌套 1. one 1. one-1 2. two-2 2. two * two-1 * two-2 one one-1 two-2 two two-1 two-2 列表嵌套代码块注：换行+Tab * one var a = 10; // 与上行保持空行并 递进缩进 one var a = 10; // 与上行保持空行并 递进缩进 ↑ 回到目录 引用 引用以>来表示，引用中支持多级引用、标题、列表、代码块、分割线等常规语法。 常见的引用写法： > 这是一段引用 //在`>`后面有 1 个空格 > > 这是引用的代码块形式 //在`>`后面有 5 个空格 > > 代码例子： > protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } > 一级引用 >> 二级引用 >>> 三级引用 > > 1. 这是第一行列表项 > 2. 这是第二行列表项 效果如下： 这是一段引用 //在>后面有 1 个空格 这是引用的代码块形式 //在`>`后面有 5 个空格 代码例子： protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } 一级引用 二级引用 三级引用 这是第一行列表项 这是第二行列表项 ↑ 回到目录 强调 两个*或_代表加粗，一个*或_代表斜体，~~代表删除。 **加粗文本** 或者 __加粗文本__ *斜体文本* 或者_斜体文本_ ~~删除文本~~ 效果如下： 加粗文本 或者 加粗文本 斜体文本 或者 斜体文本 删除文本 ↑ 回到目录 转义 使用\\来插入一些在语法中有其它意义的符号，如*。 \\\\ 反斜线 \\` 反引号 \\* 星号 \\_ 底线 \\{\\} 花括号 \\[\\] 方括号 \\(\\) 括弧 \\# 井字号 \\+ 加号 \\- 减号 \\. 英文句点 \\! 惊叹号 演示： \\ 反斜线` 反引号 * 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 ↑ 回到目录 图片与链接 图片与链接的语法很像，区别在一个 ! 号。二者格式： 图片：![]() ![图片文本(可忽略)](图片地址) 图片带有链接：[![](../imgs/img.png '百度')](http://www.baidu.com) [![图片文本(可忽略)](图片地址)](链接地址) 链接：[]() [链接文本](链接地址) 图片演示： 图片带有链接： 链接演示： 美女在这里 ↑ 回到目录 代码 代码分为行内代码和代码块。 行内代码使用一对 ` 标识，可嵌入文字。 代码块使用一对```标识，可嵌入代码。这里是代码块 代码语法高亮在 ```后面加上空格和语言名称即可protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } ↑ 回到目录 分隔线 在一行中用三个以上的*、-、_来建立一个分隔线，行内不能有其他东西。也可以在符号间插入空格。这里推荐使用-。 *** --- ___ * * * 效果均为一条分割线： ↑ 回到目录 换行 在行尾添加两个空格加回车表示换行： 这是一行后面加两个空格 换行 效果如下： 这是一行后面加两个空格换行 ↑ 回到目录 脚注 使用来定义脚注： Markdown[^1] [^1]: Markdown是一种纯文本标记语言 效果如下： Markdown1 1. Markdown是一种纯文本标记语言 ↩ ↑ 回到目录 表格 注： : 代表对齐方式，: 与 | 之间不要有空格，否则对齐会有些不兼容 | a | b | c | |:-------:|:------------- | ----------:| | 居中 | 左对齐 | 右对齐 | |=========|===============|============| 演示： a b c 居中 左对齐 右对齐 ========= =============== ============ ↑ 回到目录 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/principle.html":{"url":"design/principle.html","title":"原则","keywords":"","body":"原则 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/principle/introduction.html":{"url":"design/principle/introduction.html","title":"引言","keywords":"","body":"引言 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/principle/proximity.html":{"url":"design/principle/proximity.html","title":"亲密性","keywords":"","body":"亲密性 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/principle/alignment.html":{"url":"design/principle/alignment.html","title":"对齐","keywords":"","body":"对齐 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/principle/contrast.html":{"url":"design/principle/contrast.html","title":"对比","keywords":"","body":"对比 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/principle/pepetition.html":{"url":"design/principle/pepetition.html","title":"重复","keywords":"","body":"重复 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/principle/make-it-direct.html":{"url":"design/principle/make-it-direct.html","title":"直截了当","keywords":"","body":"直截了当 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/principle/keep-it-lightweight.html":{"url":"design/principle/keep-it-lightweight.html","title":"简化交互","keywords":"","body":"简化交互 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/principle/stay-on-the-page.html":{"url":"design/principle/stay-on-the-page.html","title":"足不出户","keywords":"","body":"足不出户 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/principle/provide-invitation.html":{"url":"design/principle/provide-invitation.html","title":"提供邀请","keywords":"","body":"提供邀请 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/principle/use-transition.html":{"url":"design/principle/use-transition.html","title":"巧用过度","keywords":"","body":"巧用过度 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/principle/react-immediately.html":{"url":"design/principle/react-immediately.html","title":"及时反应","keywords":"","body":"及时反应 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/color.html":{"url":"design/color.html","title":"色彩","keywords":"","body":"色彩 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/icon.html":{"url":"design/icon.html","title":"图标","keywords":"","body":"图标 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/font.html":{"url":"design/font.html","title":"字体","keywords":"","body":"字体 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/copy-write.html":{"url":"design/copy-write.html","title":"文案","keywords":"","body":"文案 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/layout.html":{"url":"design/layout.html","title":"布局","keywords":"","body":"布局 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/navigation.html":{"url":"design/navigation.html","title":"导航","keywords":"","body":"导航 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/data-entry.html":{"url":"design/data-entry.html","title":"数据录入","keywords":"","body":"数据录入 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/data-display.html":{"url":"design/data-display.html","title":"数据展示","keywords":"","body":"数据展示 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"design/feedback.html":{"url":"design/feedback.html","title":"反馈","keywords":"","body":"反馈 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/principle.html":{"url":"client/principle.html","title":"基本原则","keywords":"","body":"规范说明 此为前端开发团队遵循和约定的代码书写规范，意在提高代码的规范性和可维护性，统一团队编码规范和风格。让所有代码都是有规可循的，并且能够得到沉淀，减少重复劳动。通过代码风格的一致性，降低维护代码的成本以及改善多人协作的效率。同时遵守最佳实践，确保页面性能得到最佳优化和高效的代码。 此手册是在开发中积累下来的经验和参考其它规范/指南制定的，它只是起指导作用，除个别条目强制之外，大多数为非强制约束，开发者可根据自己的实际情况自行决定是否要遵守 该指南只是保证大方向一致性和最佳实践的阶段性总结，不是最后结论，它会随着时间而变化。 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/devtool.html":{"url":"client/devtool.html","title":"开发工具","keywords":"","body":"前端开发工具 Visual Studio Code简介 Visual Studio Code（以下简称vscode）是一个轻量且强大的代码编辑器，支持Windows，OS X和Linux。内置JavaScript、TypeScript和Node.js支持，而且拥有丰富的插件生态系统，可通过安装插件来支持C++、C#、Python、PHP等其他语言。 推荐插件 Auto Close Tag（修改 html 标签，自动帮你完成尾部闭合标签的同步修改） vscode-icon （让 vscode 资源树目录加上图标，必备良品！） Debugger for Chrome （） Path Intellisense （自动路劲补全，默认不带这个功能的） ESlint （ESlint 接管原生 js 提示，可以自定制提示规则） 首先安装vscode的插件 ESLint 在vscode设置里添加 \"eslint.validate\": [ \"javascript\", \"javascriptreact\", \"html\", { \"language\": \"html\", \"autoFix\": true }, { \"language\": \"vue\", \"autoFix\": true } ], \"eslint.autoFixOnSave\": true 在项目根目录下创建 .eslintrc.js 文件，内容如下： module.exports = { root: true, parser: 'babel-eslint', parserOptions: { sourceType: 'module' }, env: { browser: true, node: true, es6: true }, extends: 'eslint:recommended', // required to lint *.vue files plugins: ['html'], // check if imports actually resolve settings: { 'import/resolver': { webpack: { config: 'build/webpack.base.conf.js' } } }, // add your custom rules here //it is base on https://github.com/vuejs/eslint-config-vue rules: { 'accessor-pairs': 2, 'arrow-spacing': [ 2, { before: true, after: true } ], 'block-spacing': [2, 'always'], 'brace-style': [ 2, '1tbs', { allowSingleLine: true } ], camelcase: [ 0, { properties: 'always' } ], 'comma-dangle': [2, 'never'], 'comma-spacing': [ 2, { before: false, after: true } ], 'comma-style': [2, 'last'], 'constructor-super': 2, curly: [2, 'multi-line'], 'dot-location': [2, 'property'], 'eol-last': 2, eqeqeq: [2, 'allow-null'], 'generator-star-spacing': [ 2, { before: true, after: true } ], 'handle-callback-err': [2, '^(err|error)$'], indent: [ 2, 2, { SwitchCase: 1 } ], 'jsx-quotes': [2, 'prefer-single'], 'key-spacing': [ 2, { beforeColon: false, afterColon: true } ], 'keyword-spacing': [ 2, { before: true, after: true } ], 'new-cap': [ 2, { newIsCap: true, capIsNew: false } ], 'new-parens': 2, 'no-array-constructor': 2, 'no-caller': 2, 'no-console': 'off', 'no-class-assign': 2, 'no-cond-assign': 2, 'no-const-assign': 2, 'no-control-regex': 0, 'no-delete-var': 2, 'no-dupe-args': 2, 'no-dupe-class-members': 2, 'no-dupe-keys': 2, 'no-duplicate-case': 2, 'no-empty-character-class': 2, 'no-empty-pattern': 2, 'no-eval': 2, 'no-ex-assign': 2, 'no-extend-native': 2, 'no-extra-bind': 2, 'no-extra-boolean-cast': 2, 'no-extra-parens': [2, 'functions'], 'no-fallthrough': 2, 'no-floating-decimal': 2, 'no-func-assign': 2, 'no-implied-eval': 2, 'no-inner-declarations': [2, 'functions'], 'no-invalid-regexp': 2, 'no-irregular-whitespace': 2, 'no-iterator': 2, 'no-label-var': 2, 'no-labels': [ 2, { allowLoop: false, allowSwitch: false } ], 'no-lone-blocks': 2, 'no-mixed-spaces-and-tabs': 2, 'no-multi-spaces': 2, 'no-multi-str': 2, 'no-multiple-empty-lines': [ 2, { max: 1 } ], 'no-native-reassign': 2, 'no-negated-in-lhs': 2, 'no-new-object': 2, 'no-new-require': 2, 'no-new-symbol': 2, 'no-new-wrappers': 2, 'no-obj-calls': 2, 'no-octal': 2, 'no-octal-escape': 2, 'no-path-concat': 2, 'no-proto': 2, 'no-redeclare': 2, 'no-regex-spaces': 2, 'no-return-assign': [2, 'except-parens'], 'no-self-assign': 2, 'no-self-compare': 2, 'no-sequences': 2, 'no-shadow-restricted-names': 2, 'no-spaced-func': 2, 'no-sparse-arrays': 2, 'no-this-before-super': 2, 'no-throw-literal': 2, 'no-trailing-spaces': 2, 'no-undef': 2, 'no-undef-init': 2, 'no-unexpected-multiline': 2, 'no-unmodified-loop-condition': 2, 'no-unneeded-ternary': [ 2, { defaultAssignment: false } ], 'no-unreachable': 2, 'no-unsafe-finally': 2, 'no-unused-vars': [ 2, { vars: 'all', args: 'none' } ], 'no-useless-call': 2, 'no-useless-computed-key': 2, 'no-useless-constructor': 2, 'no-useless-escape': 0, 'no-whitespace-before-property': 2, 'no-with': 2, 'one-var': [ 2, { initialized: 'never' } ], 'operator-linebreak': [ 2, 'after', { overrides: { '?': 'before', ':': 'before' } } ], 'padded-blocks': [2, 'never'], quotes: [ 2, 'single', { avoidEscape: true, allowTemplateLiterals: true } ], semi: [2, 'never'], 'semi-spacing': [ 2, { before: false, after: true } ], 'space-before-blocks': [2, 'always'], 'space-before-function-paren': [2, 'never'], 'space-in-parens': [2, 'never'], 'space-infix-ops': 2, 'space-unary-ops': [ 2, { words: true, nonwords: false } ], 'spaced-comment': [ 2, 'always', { markers: ['global', 'globals', 'eslint', 'eslint-disable', '*package', '!', ','] } ], 'template-curly-spacing': [2, 'never'], 'use-isnan': 2, 'valid-typeof': 2, 'wrap-iife': [2, 'any'], 'yield-star-spacing': [2, 'both'], yoda: [2, 'never'], 'prefer-const': 2, 'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0, 'object-curly-spacing': [ 2, 'always', { objectsInObjects: false } ], 'array-bracket-spacing': [2, 'never'] } } Prettier （前端的代码格式化工具） 首先安装vscode的插件 Prettier 和 vetur 在vscode设置里添加\"vetur.format.defaultFormatter.html\":\"js-beautify-html\" Vetur （Vue工具） 主题 One Dark Pro (漂亮！) Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/developer.html":{"url":"client/developer.html","title":"开发规范","keywords":"","body":"开发规范 你是否常常碰到以下问题：你总是看不懂他写的代码，或者读起来很吃力；你需要改他的代码却无从下手，或总是要去问他这里是什么改了会不会影响其他代码；你和他一起开发一个产品，你总是怕代码和他有冲突或互相影响；你的代码在多次维护任务之后变得越来越臃肿，越来越难以维护。 解决以上问题只需一种方法——读规范！ Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/developer/prepare.html":{"url":"client/developer/prepare.html","title":"开发准备","keywords":"","body":"开发准备 了解产品和设计 参加需求、交互、视觉会议，了解产品设计和项目成员。 了解产品面向的设备和平台。 了解产品对兼容性的要求以及是否采用响应式设计等。 了解产品要使用的技术（WEB技术、桌面技术、APP技术、模板语言、混合模式等）。 提出疑问和见解 在交互或视觉会议中结合技术要求，提出疑问和见解。 提出可能存在的问题（技术实现问题、性能问题等），协商解决方案（如优雅退化）并达成共识。 提出已有新技术可能在产品中的应用场景，协助产品创新。 技术调研和培训 是否需要技术调研，提出可能存在的风险。 进行技术调研，产出技术demo，展示demo，反馈调研结果。 技术调研的内容可以先咨询经验丰富的前端工程师或前端技术组。 经验不足或新入职员工，可提出培训申请。 预算人力和时间 根据项目时间要求及工作量，预算人力和时间。 预算开发周期和阶段性产出。 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/developer/course.html":{"url":"client/developer/course.html","title":"开发过程","keywords":"","body":"开发过程 职责任务 确定一个页面工程师负责人，他将负责对整个页面开发工作做统筹规划、分配协调等管理工作和主开发职责。 确认交互原型或视觉效果已经定稿，再开始开发工作。 如果采取并行模式（视觉设计和页面开发同时进行），则以交互原型定稿为准（当视觉效果定稿后，页面工程师再补充细节），开始分配。 按页面类型分配，同一类型页面分配给同一个人。 每个人都要了解页面公共元素（多个页面中相同或相似部分），一个公共元素只分配到一个人，每人完成自身页面的同时完成“提取剥离”，你可能需要了解“分类方法规范”。 由于图片无法使用SVN合并和解决冲突，切图需要统筹分配。 在项目管理平台中创建细分的开发任务，填写任务详情和时间，如果任务间存在关系，则设置好关联或从属关系。 页面开发 创建前端目录，包含“页面开发”目录（如:js、css、html、img）及“提取剥离”目录（如：demo）。 使用定好的框架创建前端文件，如：css/.css、html/.html、demo/grid.html、demo/module.html、demo/unit.html。 和交互、视觉及其他前端工程师或后端工程师保持良好的沟通。 及时反馈问题和建议：对效果疑问的确认、对状态缺失的补充、对优雅退化的建议、对行为结构的说明等等。 如果采取并行模式（页面开发和JS开发同时进行），则以交互原型定稿为准，JS开发工程师可并行开发业务逻辑层，当页面开发完成后再嵌入UI层。 提取剥离 页面开发的同时提取布局（grid）、模块（module）、元件（unit）至对应的HTML文件。 避免重复劳动，对页面元素一目了然，在增加元素时首先来此目录查找是否已经实现或有相似实现而只需扩展。 “提取剥离”目录中的HTML文件和“页面开发”目录中的HTML文件需保持同步维护。 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/developer/output.html":{"url":"client/developer/output.html","title":"开发产出","keywords":"","body":"开发产出 自测联调 更新、合并、解决冲突、提交。 对自己的代码进行全面的多设备测试和兼容性测试。 如果自测过程中发现别人写的代码有问题，及时反馈。 提交验收 当有阶段性产出后，页面工程师将页面提交给设计师，进行效果验收。 效果验收将主要检查视觉效果符合度（尺寸、位置、颜色、切图等）。 如有必要，可以同时提交给经验丰富的前端工程师或前端技术组，进行代码验收。 代码验收将主要检查兼容性、HTML规范和CSS规范。 交接说明 当完成验收后，通知并交给后续的开发工程师，进行模板层开发和行为逻辑开发，页面工程师需要交代可能需要他们注意的地方或者对代码的解释说明。 如果你的工作需要与别人交接，也需要交代清楚整体架构部署和代码解释。 总结分享 分享内容可以包含：架构思想、协作心得、使用NEC体会、设备特性介绍、新技术应用、调研展示、遇到的问题和解决方案等。 分享对象不限于：交互、视觉、前端及所有感兴趣的人。 变更维护 如果未经过需求变更和设计变更，原则上不允许直接进行开发变更。 变更前应了解变更原因，变更后应该及时通知后续开发工程师。 如果静态资源的版本号不是自动完成更新，你可能需要手动更新版本号。 变更和维护使用本规范中所有流程，即你可能需要重复之前部分流程。 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/html.html":{"url":"client/html.html","title":"HTML编码规范","keywords":"","body":"HTML HTML 作为描述网页结构的超文本标记语言，在百度一直有着广泛的应用。本文档的目标是使 HTML 代码风格保持一致，容易被理解和被维护。 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/html/general.html":{"url":"client/html/general.html","title":"通用约定","keywords":"","body":"通用约定 HTML基础设施 文件应以 首行顶格开始，推荐使用 。 必须申明文档的编码charset，且与文件本身编码保持一致，推荐使用UTF-8编码。 根据页面内容和需求填写适当的keywords和description。 页面title是极为重要的不可缺少的一项。 NEC：更好的CSS方案 结构顺序和视觉顺序基本保持一致 按照从上至下、从左到右的视觉顺序书写HTML结构。 有时候为了便于搜索引擎抓取，我们也会将重要内容在HTML结构顺序上提前。 用div代替table布局，可以使HTML更具灵活性，也方便利用CSS控制。 table不建议用于布局，但表现具有明显表格形式的数据，table还是首选。 结构、表现、行为三者分离，避免内联 使用link将css文件引入，并置于head中。 使用script将js文件引入，并置于body底部。 保持良好的简洁的树形结构 每一个块级元素都另起一行，每一行都使用Tab缩进对齐（head和body的子元素不需要缩进）。删除冗余的行尾的空格。 使用4个空格代替1个Tab（大多数编辑器中可设置）。 对于内容较为简单的表格，建议将tr写成单行。 你也可以在大的模块之间用空行隔开，使模块更清晰。 热门标签 ... 最热TOP5 更多» ... 另外，请做到以下几点 结构上如果可以并列书写，就不要嵌套。 如果可以写成那么就不要写成 如果结构已经可以满足视觉和语义的要求，那么就不要有额外的冗余的结构。 比如已经能满足要求，那么就不要再写成 一个标签上引用的className不要过多，越少越好。 比如不要出现这种情况： 对于一个语义化的内部标签，应尽量避免使用className。 比如在这样一个列表中，li标签中的itm应去除： Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/html/codeformat.html":{"url":"client/html/codeformat.html","title":"代码格式","keywords":"","body":"代码格式 说明文案的注释方法 采用类似标签闭合的写法，与HTML统一格式；注释文案两头空格，与CSS注释统一格式。 开始注释：（文案两头空格）。 结束注释：（文案前加\\/符号，类似标签的闭合）。 允许只有开始注释！ LOGO NAV1 NAV2 代码本身的注释方法 单行代码的注释也保持同行，两端空格；多行代码的注释起始和结尾都另起一行并左缩进对齐。 LOGO --> NAV1 NAV2 --> HTML注释在IE6中的BUG 如果两个浮动元素之间存在注释，那么可能导致布局错位或文字的BUG。 所以，这种情况下，我们通常将注释去掉，或者索性采用模板语言（ftl、vm）的注释。 严格的嵌套 尽可能以最严格的xhtml strict标准来嵌套，比如内联元素不能包含块级元素等等。 正确闭合标签且必须闭合。 严格的属性 属性和值全部小写，每个属性都必须有一个值，每个值必须加双引号。 没有值的属性必须使用自己的名称做为值（checked、disabled、readonly、selected等等）。 可以省略style标签和script标签的type属性。 常用的标签 标签 语义 嵌套常见错误 超链接/锚 a不可嵌套a 换行 按钮 不可嵌套表单元素 定义列表中的定义 只能以dl为父容器，对应一个dt 文本删除 块级容器 定义列表 只能嵌套dt和dd 定义列表中的定义术语 只能以dl为父容器，对应多个dd 强调文本 表单 标题 从h1到h6，不可嵌套块级元素 内嵌一个网页 图像 各种表单控件 标签为input元素定义标注 列表项 只能以ul或ol为父容器 引用样式或icon 不可嵌套任何元素 文档信息 只用于head 有序列表 只能嵌套li select中的一个选项 仅用于select 段落 不能嵌套块级元素 引用脚本 不可嵌套任何元素 列表框或下拉框 只能嵌套option或optgroup 内联容器 强调文本 引用样式 不可嵌套任何元素 下标 上标 表格 只可嵌套表格元素 表格主体 只用于table 表格中的单元格 只用于tr 多行文本输入控件 表格表尾 只用于table 表格中的标题单元格 只用于tr 表格表头 只用于table 文档标题 只用于head 表格行 嵌套于table或thead、tbody、tfoot 无序列表 只能嵌套li Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/html/semantic.html":{"url":"client/html/semantic.html","title":"内容语义","keywords":"","body":"内容语义 内容类型决定使用的语义标签 在网页中某种类型的内容必定需要某种特定的HTML标签来承载，也就是我们常常提到的根据你的内容语义化HTML结构。 加强“资源型”内容的可访问性和可用性 在资源型的内容上加入描述文案，比如给img添加alt属性，在audio内加入文案和链接等等。 加强“不可见”内容的可访问性 背景图上的文字应该同时写在html中，并使用css使其不可见，有利于搜索引擎抓取你的内容，也可以在css失效的情况下看到内容。 适当使用实体 以实体代替与HTML语法相同的字符，避免浏览解析错误。 常用HTML字符实体（建议使用实体）： 字符 名称 实体名 实体数 \" 双引号 &quot; &#34; & &符 &amp; &#38; 左尖括号（小于号） &lt; &#60; > 右尖括号（大于号） &gt; &#62; 空格 &nbsp; &#160; 中文全角空格 &#12288; 常用特殊字符实体（不建议使用实体）： 字符 名称 实体名 实体数 ¥ 元 &yen; &#165; ¦ 断竖线 &brvbar; &#166; © 版权 &copy; &#169; ® 注册商标R &reg; &#174; ™ 商标TM &trade; &#8482; · 间隔符 &middot; &#183; « 左双尖括号 &laquo; &#171; » 右双尖括号 &raquo; &#187; ° 度 &deg; &#176; × 乘 &times; &#215; ÷ 除 &divide; &#247; ‰ 千分比 &permil; &#8240; Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/css.html":{"url":"client/css.html","title":"CSS编码规范","keywords":"","body":"CSS CSS 作为网页样式的描述语言，在百度一直有着广泛的应用。本文档的目标是使 CSS 代码风格保持一致，容易被理解和被维护。 虽然本文档是针对 CSS 设计的，但是在使用各种 CSS 的预编译器(如 less、sass、stylus 等)时，适用的部分也应尽量遵循本文档的约定。 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/css/classify.html":{"url":"client/css/classify.html","title":"分类方法","keywords":"","body":"分类方法 CSS文件的分类和引用顺序 通常，一个项目我们只引用一个CSS，但是对于较大的项目，我们需要把CSS文件进行分类。 我们按照CSS的性质和用途，将CSS文件分成“公共型样式”、“特殊型样式”、“皮肤型样式”，并以此顺序引用（按需求决定是否添加版本号）。 公共型样式：包括了以下几个部分：“标签的重置和设置默认值”、“统一调用背景图和清除浮动或其他需统一处理的长样式”、“网站通用布局”、“通用模块和其扩展”、“元件和其扩展”、“功能类样式”、“皮肤类样式”。 特殊型样式：当某个栏目或页面的样式与网站整体差异较大或者维护率较高时，可以独立引用一个样式：“特殊的布局、模块和元件及扩展”、“特殊的功能、颜色和背景”，也可以是某个大型控件或模块的独立样式。 皮肤型样式：如果产品需要换肤功能，那么我们需要将颜色、背景等抽离出来放在这里。 CSS内部的分类及其顺序 重置（reset）和默认（base）（tags）：消除默认样式和浏览器差异，并设置部分标签的初始样式，以减少后面的重复劳动！你可以根据你的网站需求设置！ 统一处理：建议在这个位置统一调用背景图（这里指多个布局或模块或元件共用的图）和清除浮动（这里指通用性较高的布局、模块、元件内的清除）等统一设置处理的样式！ 布局（grid）（.g-）：将页面分割为几个大块，通常有头部、主体、主栏、侧栏、尾部等！ 模块（module）（.m-）：通常是一个语义化的可以重复使用的较大的整体！比如导航、登录、注册、各种列表、评论、搜索等！ 元件（unit）（.u-）：通常是一个不可再分的较为小巧的个体，通常被重复用于各种模块中！比如按钮、输入框、loading、图标等！ 功能（function）（.f-）：为方便一些常用样式的使用，我们将这些使用率较高的样式剥离出来，按需使用，通常这些选择器具有固定样式表现，比如清除浮动等！不可滥用！ 皮肤（skin）（.s-）：如果你需要把皮肤型的样式抽离出来，通常为文字色、背景色（图）、边框色等，非换肤型网站通常只提取文字色！非换肤型网站不可滥用此类！ 状态（.z-）：为状态类样式加入前缀，统一标识，方便识别，她只能组合使用或作为后代出现（.u-ipt.z-dis{}，.m-list li.z-sel{}），具体详见命名规则的扩展相关项。 功能类和皮肤类样式为表现化的样式，请不要滥用！以上顺序可以按需求适当调整。 以上分类的命名方法详见 命名规则 /* 重置 */ div,p,ul,ol,li{margin:0;padding:0;} /* 默认 */ strong,em{font-style:normal;font-weight:bold;} /* 统一调用背景图 */ .m-logo a,.m-nav a,.m-nav em{background:url(images/sprite.png) no-repeat 9999px 9999px;} /* 统一清除浮动 */ .g-bdc:after,.m-dimg ul:after,.u-tab:after{display:block;visibility:hidden;clear:both;height:0;overflow:hidden;content:'.';} .g-bdc,.m-dimg ul,.u-tab{zoom:1;} /* 布局 */ .g-sd{float:left;width:300px;} /* 模块 */ .m-logo{width:200px;height:50px;} /* 元件 */ .u-btn{height:20px;border:1px solid #333;} /* 功能 */ .f-tac{text-align:center;} /* 皮肤 */ .s-fc,a.s-fc:hover{color:#fff;} Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/css/bename.html":{"url":"client/css/bename.html","title":"命名规则","keywords":"","body":"命名规则 使用类选择器，放弃ID选择器 ID在一个页面中的唯一性导致了如果以ID为选择器来写CSS，就无法重用。 分类的命名方法：使用单个字母+\"-\"为前缀 布局（grid）（.g-）；模块（module）（.m-）；元件（unit）（.u-）；功能（function）（.f-）；皮肤（skin）（.s-）；状态（.z-）。 对以上的解释详情参见：分类方法中的“CSS内部的分类及其顺序”。 注： 在你样式中的选择器总是要以上面前五类开头，然后在里面使用后代选择器。 　　如果这五类不能满足你的需求，你可以另外定义一个或多个大类，但必须符合单个字母+\"-\"为前缀的命名规则，即 .x- 的格式。 　　特殊：.j-将被专用于JS获取节点，请勿使用.j-定义样式。 后代选择器命名 约定不以单个字母+\"-\"为前缀且长度大于等于2的类选择器为后代选择器，如：.item为m-list模块里的每一个项，.text为m-list模块里的文本部分：.m-list .item{}.m-list .text{}。 一个语义化的标签也可以是后代选择器，比如：.m-list li{}。 不允许单个字母的类选择器出现，原因详见下面的“模块和元件的后代选择器的扩展类”。 通过使用后代选择器的方法，你不需要考虑他的命名是否已被使用，因为他只在当前模块或元件中生效，同样的样式名可以在不同的模块或元件中重复使用，互不干扰；在多人协作或者分模块协作的时候效果尤为明显！ 后代选择器不需要完整表现结构树层级，尽量能短则短。 注： 后代选择器不要在页面布局中使用，因为污染的可能性较大； /* 这里的.itm和.cnt只在.m-list中有效 */ .m-list{margin:0;padding:0;} .m-list .itm{margin:1px;padding:1px;} .m-list .cnt{margin-left:100px;} /* 这里的.cnt和.num只在.m-page中有效 */ .m-page{height:20px;} .m-page .cnt{text-align:center;} .m-page .num{border:1px solid #ddd;} 命名应简约而不失语义 /* 反对：表现化的或没有语义的命名 */ .m-abc .green2{} .g-left2{} /* 推荐：使用有语义的简短的命名 */ .m-list .wrap2{} .g-side2{} 相同语义的不同类命名 方法：直接加数字或字母区分即可（如：.m-list、.m-list2、.m-list3等，都是列表模块，但是是完全不一样的模块）。 其他举例：.f-fw0、.f-fw1、.s-fc0、.s-fc1、.m-logo2、.m-logo3、u-btn、u-btn2等等。 模块和元件的扩展类的命名方法 当A、B、C、...它们类型相同且外形相似区别不大，那么就以它们中出现率最高的做成基类，其他做成基类的扩展。 方法：+“-”+数字或字母（如：.m-list的扩展类为.m-list-1、.m-list-2等）。 补充：基类自身可以独立使用（如：class=\"m-list\"即可），扩展类必须基于基类使用（如：class=\"m-list m-list-2\"）。 如果你的扩展类是表示不同状态，那么你可以这样命名：u-btn-dis，u-btn-hov，m-box-sel，m-box-hov等等，然后像这样使用：class=\"u-btn u-btn-dis\"。 如果你的网站可以不兼容IE6等浏览器，那么你标识状态的方法也可以采取独立状态分类（.z-）方法：.u-btn.z-dis，.m-box.z-sel，然后像这样使用：class=\"u-btn z-dis\"。 模块和元件的后代选择器的扩展类 有时候模块内会有些类似的东西，如果你没有把它们做成元件和扩展，那么也可以使用后代选择器和扩展。 后代选择器：.m-login .btn{}。 后代选择器扩展：.m-login .btn-1{}，.m-login .btn-dis{}。 同样也可以采取独立状态分类（.z-）方法：.m-login .btn.z-dis{}，然后像这样使用：class=\"btn z-dis\"。 注：此方法用于类选择器，直接使用标签做为选择器的则不需要使用此命名方法。 注：为防止后代选择器的扩展类和大类命名规范冲突，后代选择器不允许使用单个字母。 　　比如：.m-list .a{}是不允许的，因为当这个.a需要扩展的时候就会变成.a-bb，这样就和大类的命名规范冲突。 分组选择器有时可以代替扩展方法 有时候虽然两个同类型的模块很相似，但是你希望他们之间不要有依赖关系，也就是说你不希望使用扩展的方法，那么你可以通过合并选择器来设置共性的样式。 使用本方法的前提是：相同类型、功能和外观都相似，写在同一片代码区域方便维护。 /* 两个元件共性的样式 */ .u-tip1,.u-tip2{} .u-tip1 .itm,.u-tip2 .itm{} /* 在分别是两个元件各自的样式 */ /* tip1 */ .u-tip1{} .u-tip1 .itm{} /* tip2 */ .u-tip2{} .u-tip2 .itm{} 防止污染和被污染 当模块或元件之间互相嵌套，且使用了相同的标签选择器或其他后代选择器，那么里面的选择器就会被外面相同的选择器所影响。 所以，如果你的模块或元件可能嵌套或被嵌套于其他模块或元件，那么要慎用标签选择器，必要时采用类选择器，并注意命名方式，可以采用.m-layer .layerxxx、.m-list2 .list2xxx的形式来降低后代选择器的污染性。 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/css/codeformat.html":{"url":"client/css/codeformat.html","title":"代码格式","keywords":"","body":"代码格式 选择器、属性和值都使用小写 在xhtml标准中规定了所有标签、属性和值都小写，CSS也是如此。 单行写完一个选择器定义 便于选择器的寻找和阅读，也便于插入新选择器和编辑，便于模块等的识别。去除多余空格，使代码紧凑减少换行。 如果有嵌套定义，可以采取内部单行的形式。 /* 单行定义一个选择器 */ .m-list li,.m-list h3{width:100px;padding:10px;border:1px solid #ddd;} /* 这是一个有嵌套定义的选择器 */ @media all and (max-width:600px){ .m-class1 .itm{height:17px;line-height:17px;font-size:12px;} .m-class2 .itm{width:100px;overflow:hidden;} } @-webkit-keyframes showitm{ 0%{height:0;opacity:0;} 100%{height:100px;opacity:1;} } 最后一个值也以分号结尾 通常在大括号结束前的值可以省略分号，但是这样做会对修改、添加和维护工作带来不必要的失误和麻烦。 省略值为0时的单位 为节省不必要的字节同时也使阅读方便，我们将0px、0em、0%等值缩写为0。 .m-box{margin:0 10px;background-position:50% 0;} 使用单引号 省略url引用中的引号，其他需要引号的地方使用单引号。 .m-box{background:url(bg.png);} .m-box:after{content:'.';} 使用16进制表示颜色值 除非你需要透明度而使用rgba，否则都使用#f0f0f0这样的表示方法，并尽量缩写。 .m-box{color:#f00;background:rgba(0,0,0,0.5);} 根据属性的重要性按顺序书写 只遵循横向顺序即可，先显示定位布局类属性，后盒模型等自身属性，最后是文本类及修饰类属性。 → 显示属性 自身属性 文本属性和其他修饰 display width font visibility height text-align position margin text-decoration float padding vertical-align clear border white-space list-style overflow color top min-width background .m-box{position:relative;width:600px;margin:0 auto 10px;text-align:center;color:#000;} 如果属性间存在关联性，则不要隔开写。 /* 这里的height和line-height有关联性 */ .m-box{position:relative;height:20px;line-height:20px;padding:5px;color:#000;} 私有在前，标准在后 先写带有浏览器私有标志的，后写W3C标准的。 .m-box{-webkit-box-shadow:0 0 0 #000;-moz-box-shadow:0 0 0 #000;box-shadow:0 0 0 #000;} 注释格式：/* 注释文字 */ 对选择器的注释统一写在被注释对象的上一行，对属性及值的注释写于分号后。 注释内容两端需空格，已确保即使在编码错误的情况下也可以正确解析样式。 在必要的情况下，可以使用块状注释，块状注释保持统一的缩进对齐。 原则上每个系列的样式都需要有一个注释，言简意赅的表明名称、用途、注意事项等。 /* 块状注释文字 * 块状注释文字 * 块状注释文字 */ .m-list{width:500px;} .m-list li{height:20px;line-height:20px;/* 这里是对line-height的一个注释 */overflow:hidden;} .m-list li a{color:#333;} /* 单行注释文字 */ .m-list li em{color:#666;} 原则上不允许使用Hack 很多不兼容问题可以通过改变方法和思路来解决，并非一定需要Hack，根据经验你完全可以绕过某些兼容问题。 一种合理的结构和合理的样式，是极少会碰到兼容问题的。 由于浏览器自身缺陷，我们无法避开的时候，可以允许使用适当的Hack。 统一Hack方法 统一使用“*”和“_”分别对IE7和6进行Hack。如下代码所示： /* IE7会显示灰色#888，IE6会显示白色#fff，其他浏览器显示黑色#000 */ .m-list{color:#000;*color:#888;_color:#fff;} 建议并适当缩写值 “建议并适当”是因为缩写总是会包含一系列的值，而有时候我们并不希望设置某一值，反而造成了麻烦，那么这时候你可以不缩写，而是分开写。 当然，在一切可以缩写的情况下，请务必缩写，它最大的好处就是节省了字节，便于维护，并使阅读更加一目了然。 缩写方法请查阅css手册。 选择器顺序 请综合考虑以下顺序依据： 从大到小（以选择器的范围为准） 从低到高（以等级上的高低为准） 从先到后（以结构上的先后为准） 从父到子（以结构上的嵌套为准） 以下仅为简单示范： /* 从大到小 */ .m-list p{margin:0;padding:0;} .m-list p.part{margin:1px;padding:1px;} /* 从低到高 */ .m-logo a{color:#f00;} .m-logo a:hover{color:#fff;} /* 从先到后 */ .g-hd{height:60px;} .g-bd{height:60px;} .g-ft{height:60px;} /* 从父到子 */ .m-list{width:300px;} .m-list .itm{float:left;} 选择器等级 a = 行内样式style。 b = ID选择器的数量。 c = 类、伪类和属性选择器的数量。 d = 类型选择器和伪元素选择器的数量。 选择器 等级(a,b,c,d) style=”” 1,0,0,0 #wrapper #content {} 0,2,0,0 #content .dateposted {} 0,1,1,0 div#content {} 0,1,0,1 #content p {} 0,1,0,1 #content {} 0,1,0,0 p.comment .dateposted {} 0,0,2,1 div.comment p {} 0,0,1,2 .comment p {} 0,0,1,1 p.comment {} 0,0,1,1 .comment {} 0,0,1,0 div p {} 0,0,0,2 p {} 0,0,0,1 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/css/optimization.html":{"url":"client/css/optimization.html","title":"优化方案","keywords":"","body":"优化方案 值缩写 缩写值可以减少CSS文件大小，并增加可读性和可维护性。 但并非所有的值都必须缩写，因为当一个属性的值缩写时，总是会将所有项都设置一遍，而有时候我们不希望设置值里的某些项。 /* 比如我们用下面这个样式来让某个定宽的容器水平居中，我们要的只是left和right， * 而top和bottom不是这个样式要关心的（如果设置了反倒会影响其他样式在这个容器上的使用）， * 所以这时我们就不需要缩写 */ .f-mgha{margin-left:auto;margin-right:auto;} /* 比如下面这个模块的样式设置，我们确实需要设置padding的所有项，于是我们就可以采用缩写 */ .m-link{padding:6px 12px;} 常用的缩写方法请参见 代码格式。 避免耗性能的属性 以下所举列的属性可能造成渲染性能问题。不过有时候需求大于一切…… /* expression */ .class{width:expression(this.width>100?'100px':'auto');} /* filter */ .class{filter:alpha(opacity=50);} 选择器合并 即CSS选择器组合，可以一次定义多个选择器，为你节省很多字节和宝贵时间。 通常我们会将定义相同的或者有大部分属性值相同（确实是因为相关而相同）的一系列选择器组合到一起（采用逗号的方法）来统一定义。 /* 以下对布局类选择器统一做了清除浮动的操作 */ .g-hd:after,.g-bd:after,.g-ft:after{display:block;visibility:hidden;clear:both;height:0;content:\".\";} .g-hd,.g-bd,.g-ft{zoom:1;} /* 通常background总是会占用很多字节，所以一般情况下，我们都会这样统一调用 */ .m-logo,.m-help,.m-list li,.u-tab li,.u-tab li a{background:url(../images/sprite.png) no-repeat 9999px 9999px;} .m-logo{background-position:0 0;} /* 以下是某个元件的写法，因为确实很多元素是联动的或相关的，所以采用了组合写法，可以方便理解和修改 */ .u-tab li,.u-tab li a{display:inline;float:left;height:30px;line-height:30px;} .u-tab li{margin:0 3px;} .u-tab li a{padding:0 6px;} 背景图优化合并 图片本身的优化： 图像质量要求和图像文件大小决定你用什么格式的图片，用较小的图片文件呈现较好的图像质量。 当图片色彩过于丰富且无透明要求时，建议采用jpg格式并保存为较高质量。 当图片色彩过于丰富又有透明或半透明要求或阴影效果时，建议采用png24格式，并对IE6进行png8退化（或在不得已情况下使用滤镜）。 当图片色彩不太丰富时无论有无透明要求，请采用png8格式，大多数情况下建议采用这种格式。 当图片有动画时，只能使用gif格式。 你可以使用工具对图片进行再次压缩，但前提是不会影响色彩和透明。 多张图片的合并： 单个图标之间必须保留空隙，空隙大小由容器大小及显示方式决定。这样做的好处是既考虑了“容错性”又提高了图片的可维护性。 图标的排列方式，也由容器大小及显示方式决定。排列方式分为以下几种：横向排列（容器宽度有限）、纵向排列（容器高度有限）、斜线排列（容器宽高不限），靠左排列（容器背景居左）、靠右排列（容器背景居右）、水平居中排列（容器背景水平居中）、垂直居中排列（容器背景垂直居中）。 合并后图片大小不宜超过50K，建议大小在20K-50K之间。 为保证多次修改后的图片质量，请保留一份PSD原始图，修改和添加都在PSD中进行，最后导出png。 分类合并： 并不是把所有的图标都合并在一张图片里就是最好的，除了要控制图片大小之外还要注意以下方法。 按照图片排列方式，把排列方式一样的图片进行合并，便于样式控制。 按照模块或元件，把同属于一个模块或元件的图片进行合并，方便模块或元件的维护。 按照图片大小，把大小一致或差不多的图片进行合并，可充分利用图片空间。 按照图片色彩，把色彩一致或差不多的图片进行合并，保证合并后图片的色彩不过于丰富，可防止色彩失真。 综合以上方法进行合并。 Hack的避免 当避免的代价较大时，可以使用Hack而不避免，比如你需要增加很多HTML或多写很多CSS时会得不偿失。 丰富的实战经验可以帮助你了解那些常见问题并用多种不同的思路来避免它，所以经验和思维方法在这里显得很重要。 根据你自己的能力来解决Hack的问题，我们不建议你用一个自己都没有把握的方法来避免Hack，因为也许你这个方法本身存在你没有发现的问题。 如果CSS可以做到，就不要使用JS 让CSS做更多的事，减轻JS开发量。 用CSS控制交互或视觉的变化，JS只需要更改className。 利用CSS一次性更改多个节点样式，避免多次渲染，提高渲染效率。 如果你的产品允许不兼容低版本浏览器，那么动画实现可以交给CSS。 便于阅读修改 如果你做到了“CSS规范”的所有要求，自然你也就写出了一个便于阅读和修改的漂亮的CSS。 当然，代码格式和命名规则是相对重要一些的。 清晰的CSS模块 如果你做到了命名规则的要求，你的CSS模块也就清晰可见了。 用“注释”来说明每一个模块对于较大的CSS文件来说显得尤为重要。 文件压缩 合理的书写CSS能很大程度上减少文件大小，完成后，在不损坏文件内容的情况下，想尽一切办法压缩你的CSS，你可以借助压缩工具把注释和多余的空格、换行去掉。 压缩工具详见：“HTML/CSS工具”部分。 其他格式优化 优化方法请参见代码格式。 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/css/practice.html":{"url":"client/css/practice.html","title":"最佳实践","keywords":"","body":"最佳实践 最佳选择器写法（模块） /* 这是某个模块 */ .m-nav{}/* 模块容器 */ .m-nav li,.m-nav a{}/* 先共性 优化组合 */ .m-nav li{}/* 后个性 语义化标签选择器 */ .m-nav a{}/* 后个性中的共性 按结构顺序 */ .m-nav a.a1{}/* 后个性中的个性 */ .m-nav a.a2{}/* 后个性中的个性 */ .m-nav .z-crt a{}/* 交互状态变化 */ .m-nav .z-crt a.a1{} .m-nav .z-crt a.a2{} .m-nav .btn{}/* 典型后代选择器 */ .m-nav .btn-1{}/* 典型后代选择器扩展 */ .m-nav .btn-dis{}/* 典型后代选择器扩展（状态） */ .m-nav .btn.z-dis{}/* 作用同上，请二选一（如果可以不兼容IE6时使用） */ .m-nav .m-sch{}/* 控制内部其他模块位置 */ .m-nav .u-sel{}/* 控制内部其他元件位置 */ .m-nav-1{}/* 模块扩展 */ .m-nav-1 li{} .m-nav-dis{}/* 模块扩展（状态） */ .m-nav.z-dis{}/* 作用同上，请二选一（如果可以不兼容IE6时使用） */ 统一语义理解和命名 布局（.g-） 语义 命名 简写 文档 doc doc 头部 head hd 主体 body bd 尾部 foot ft 主栏 main mn 主栏子容器 mainc mnc 侧栏 side sd 侧栏子容器 sidec sdc 盒容器 wrap/box wrap/box 模块（.m-）、元件（.u-） 语义 命名 简写 导航 nav nav 子导航 subnav snav 面包屑 crumb crm 菜单 menu menu 选项卡 tab tab 标题区 head/title hd/tt 内容区 body/content bd/ct 列表 list lst 表格 table tb 表单 form fm 热点 hot hot 排行 top top 登录 login log 标志 logo logo 广告 advertise ad 搜索 search sch 幻灯 slide sld 提示 tips tips 帮助 help help 新闻 news news 下载 download dld 注册 regist reg 投票 vote vote 版权 copyright cprt 结果 result rst 标题 title tt 按钮 button btn 输入 input ipt 功能（.f-） 语义 命名 简写 浮动清除 clearboth cb 向左浮动 floatleft fl 向右浮动 floatright fr 内联块级 inlineblock ib 文本居中 textaligncenter tac 文本居右 textalignright tar 文本居左 textalignleft tal 垂直居中 verticalalignmiddle vam 溢出隐藏 overflowhidden oh 完全消失 displaynone dn 字体大小 fontsize fs 字体粗细 fontweight fw 皮肤（.s-） 语义 命名 简写 字体颜色 fontcolor fc 背景 background bg 背景颜色 backgroundcolor bgc 背景图片 backgroundimage bgi 背景定位 backgroundposition bgp 边框颜色 bordercolor bdc 状态（.z-） 语义 命名 简写 选中 selected sel 当前 current crt 显示 show show 隐藏 hide hide 打开 open open 关闭 close close 出错 error err 不可用 disabled dis Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/javascript.html":{"url":"client/javascript.html","title":"JavaScript编码规范","keywords":"","body":"JavaScript 目录 类型 引用 对象 数组 解构 字符串 函数 箭头函数 构造函数 模块 迭代器和生成器 属性 变量 提升 比较运算符和等号 代码块 注释 空白 逗号 分号 类型转换 命名规则 存取器 事件 jQuery 类型 1.1 基本类型: 直接存取基本类型。 字符串 数值 布尔类型 null undefined const foo = 1; let bar = foo; bar = 9; console.log(foo, bar); // => 1, 9 1.2 复杂类型: 通过引用的方式存取复杂类型。 对象 数组 函数 const foo = [1, 2]; const bar = foo; bar[0] = 9; console.log(foo[0], bar[0]); // => 9, 9 ⬆ 返回目录 引用 2.1 对所有的引用使用 const ；不要使用 var。 为什么？这能确保你无法对引用重新赋值，也不会导致出现 bug 或难以理解。 // bad var a = 1; var b = 2; // good const a = 1; const b = 2; 2.2 如果你一定需要可变动的引用，使用 let 代替 var。 为什么？因为 let 是块级作用域，而 var 是函数作用域。 // bad var count = 1; if (true) { count += 1; } // good, use the let. let count = 1; if (true) { count += 1; } 2.3 注意 let 和 const 都是块级作用域。 // const 和 let 只存在于它们被定义的区块内。 { let a = 1; const b = 1; } console.log(a); // ReferenceError console.log(b); // ReferenceError ⬆ 返回目录 对象 3.1 使用字面值创建对象。 // bad const item = new Object(); // good const item = {}; 3.2 如果你的代码在浏览器环境下执行，别使用 保留字 作为键值。这样的话在 IE8 不会运行。 更多信息。 但在 ES6 模块和服务器端中使用没有问题。 // bad const superman = { default: { clark: 'kent' }, private: true, }; // good const superman = { defaults: { clark: 'kent' }, hidden: true, }; 3.3 使用同义词替换需要使用的保留字。 // bad const superman = { class: 'alien', }; // bad const superman = { klass: 'alien', }; // good const superman = { type: 'alien', }; 3.4 创建有动态属性名的对象时，使用可被计算的属性名称。 为什么？因为这样可以让你在一个地方定义所有的对象属性。 function getKey(k) { return 'a key named ${k}'; } // bad const obj = { id: 5, name: 'San Francisco', }; obj[getKey('enabled')] = true; // good const obj = { id: 5, name: 'San Francisco', [getKey('enabled')]: true, }; 3.5 使用对象方法的简写。 // bad const atom = { value: 1, addValue: function (value) { return atom.value + value; }, }; // good const atom = { value: 1, addValue(value) { return atom.value + value; }, }; 3.6 使用对象属性值的简写。 为什么？因为这样更短更有描述性。 const lukeSkywalker = 'Luke Skywalker'; // bad const obj = { lukeSkywalker: lukeSkywalker, }; // good const obj = { lukeSkywalker, }; 3.7 在对象属性声明前把简写的属性分组。 为什么？因为这样能清楚地看出哪些属性使用了简写。 const anakinSkywalker = 'Anakin Skywalker'; const lukeSkywalker = 'Luke Skywalker'; // bad const obj = { episodeOne: 1, twoJedisWalkIntoACantina: 2, lukeSkywalker, episodeThree: 3, mayTheFourth: 4, anakinSkywalker, }; // good const obj = { lukeSkywalker, anakinSkywalker, episodeOne: 1, twoJedisWalkIntoACantina: 2, episodeThree: 3, mayTheFourth: 4, }; ⬆ 返回目录 数组 4.1 使用字面值创建数组。 // bad const items = new Array(); // good const items = []; 4.2 向数组添加元素时使用 Arrary#push 替代直接赋值。 ```javascript const someStack = []; // bad someStack[someStack.length] = 'abracadabra'; // good someStack.push('abracadabra'); ``` 4.3 使用拓展运算符 ... 复制数组。 // bad const len = items.length; const itemsCopy = []; let i; for (i = 0; i 4.4 使用 Array#from 把一个类数组对象转换成数组。 const foo = document.querySelectorAll('.foo'); const nodes = Array.from(foo); ⬆ 返回目录 解构 5.1 使用解构存取和使用多属性对象。 为什么？因为解构能减少临时引用属性。 // bad function getFullName(user) { const firstName = user.firstName; const lastName = user.lastName; return `${firstName} ${lastName}`; } // good function getFullName(obj) { const { firstName, lastName } = obj; return `${firstName} ${lastName}`; } // best function getFullName({ firstName, lastName }) { return `${firstName} ${lastName}`; } 5.2 对数组使用解构赋值。 const arr = [1, 2, 3, 4]; // bad const first = arr[0]; const second = arr[1]; // good const [first, second] = arr; 5.3 需要回传多个值时，使用对象解构，而不是数组解构。 为什么？增加属性或者改变排序不会改变调用时的位置。 // bad function processInput(input) { // then a miracle occurs return [left, right, top, bottom]; } // 调用时需要考虑回调数据的顺序。 const [left, __, top] = processInput(input); // good function processInput(input) { // then a miracle occurs return { left, right, top, bottom }; } // 调用时只选择需要的数据 const { left, right } = processInput(input); ⬆ 返回目录 Strings 6.1 字符串使用单引号 '' 。 // bad const name = \"Capt. Janeway\"; // good const name = 'Capt. Janeway'; 6.2 字符串超过 80 个字节应该使用字符串连接号换行。 6.3 注：过度使用字串连接符号可能会对性能造成影响。jsPerf 和 讨论. // bad const errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'; // bad const errorMessage = 'This is a super long error that was thrown because \\ of Batman. When you stop to think about how Batman had anything to do \\ with this, you would get nowhere \\ fast.'; // good const errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.'; 6.4 程序化生成字符串时，使用模板字符串代替字符串连接。 为什么？模板字符串更为简洁，更具可读性。 // bad function sayHi(name) { return 'How are you, ' + name + '?'; } // bad function sayHi(name) { return ['How are you, ', name, '?'].join(); } // good function sayHi(name) { return `How are you, ${name}?`; } ⬆ 返回目录 函数 7.1 使用函数声明代替函数表达式。 为什么？因为函数声明是可命名的，所以他们在调用栈中更容易被识别。此外，函数声明会把整个函数提升（hoisted），而函数表达式只会把函数的引用变量名提升。这条规则使得箭头函数可以取代函数表达式。 // bad const foo = function () { }; // good function foo() { } 7.2 函数表达式: // 立即调用的函数表达式 (IIFE) (() => { console.log('Welcome to the Internet. Please follow me.'); })(); 7.3 永远不要在一个非函数代码块（if、while 等）中声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但它们的解析表现不一致。 7.4 注意: ECMA-262 把 block 定义为一组语句。函数声明不是语句。阅读 ECMA-262 关于这个问题的说明。 // bad if (currentUser) { function test() { console.log('Nope.'); } } // good let test; if (currentUser) { test = () => { console.log('Yup.'); }; } 7.5 永远不要把参数命名为 arguments。这将取代原来函数作用域内的 arguments 对象。 // bad function nope(name, options, arguments) { // ...stuff... } // good function yup(name, options, args) { // ...stuff... } 7.6 不要使用 arguments。可以选择 rest 语法 ... 替代。 为什么？使用 ... 能明确你要传入的参数。另外 rest 参数是一个真正的数组，而 arguments 是一个类数组。 // bad function concatenateAll() { const args = Array.prototype.slice.call(arguments); return args.join(''); } // good function concatenateAll(...args) { return args.join(''); } 7.7 直接给函数的参数指定默认值，不要使用一个变化的函数参数。 // really bad function handleThings(opts) { // 不！我们不应该改变函数参数。 // 更加糟糕: 如果参数 opts 是 false 的话，它就会被设定为一个对象。 // 但这样的写法会造成一些 Bugs。 //（译注：例如当 opts 被赋值为空字符串，opts 仍然会被下一行代码设定为一个空对象。） opts = opts || {}; // ... } // still bad function handleThings(opts) { if (opts === void 0) { opts = {}; } // ... } // good function handleThings(opts = {}) { // ... } 7.8 直接给函数参数赋值时需要避免副作用。 为什么？因为这样的写法让人感到很困惑。 var b = 1; // bad function count(a = b++) { console.log(a); } count(); // 1 count(); // 2 count(3); // 3 count(); // 3 ⬆ 返回目录 箭头函数 8.1 当你必须使用函数表达式（或传递一个匿名函数）时，使用箭头函数符号。 为什么？因为箭头函数创造了新的一个 this 执行环境（译注：参考 Arrow functions - JavaScript | MDN 和 ES6 arrow functions, syntax and lexical scoping），通常情况下都能满足你的需求，而且这样的写法更为简洁。 为什么不？如果你有一个相当复杂的函数，你或许可以把逻辑部分转移到一个函数声明上。 // bad [1, 2, 3].map(function (x) { const y = x + 1; return x * y; }); // good [1, 2, 3].map((x) => { const y = x + 1; return x * y; }); 8.2 如果一个函数适合用一行写出并且只有一个参数，那就把花括号、圆括号和 return 都省略掉。如果不是，那就不要省略。 为什么？语法糖。在链式调用中可读性很高。 为什么不？当你打算回传一个对象的时候。 // good [1, 2, 3].map(x => x * x); // good [1, 2, 3].reduce((total, n) => { return total + n; }, 0); ⬆ 返回目录 构造器 9.1 总是使用 class。避免直接操作 prototype 。 为什么? 因为 class 语法更为简洁更易读。 ```javascript // bad function Queue(contents = []) { this._queue = [...contents]; } Queue.prototype.pop = function() { const value = this._queue[0]; this._queue.splice(0, 1); return value; } // good class Queue { constructor(contents = []) { this._queue = [...contents]; } pop() { const value = this._queue[0]; this._queue.splice(0, 1); return value; } } ``` 9.2 使用 extends 继承。 为什么？因为 extends 是一个内建的原型继承方法并且不会破坏 instanceof。 // bad const inherits = require('inherits'); function PeekableQueue(contents) { Queue.apply(this, contents); } inherits(PeekableQueue, Queue); PeekableQueue.prototype.peek = function() { return this._queue[0]; } // good class PeekableQueue extends Queue { peek() { return this._queue[0]; } } 9.3 方法可以返回 this 来帮助链式调用。 // bad Jedi.prototype.jump = function() { this.jumping = true; return true; }; Jedi.prototype.setHeight = function(height) { this.height = height; }; const luke = new Jedi(); luke.jump(); // => true luke.setHeight(20); // => undefined // good class Jedi { jump() { this.jumping = true; return this; } setHeight(height) { this.height = height; return this; } } const luke = new Jedi(); luke.jump() .setHeight(20); 9.4 可以写一个自定义的 toString() 方法，但要确保它能正常运行并且不会引起副作用。 class Jedi { constructor(options = {}) { this.name = options.name || 'no name'; } getName() { return this.name; } toString() { return `Jedi - ${this.getName()}`; } } ⬆ 返回目录 模块 10.1 总是使用模组 (import/export) 而不是其他非标准模块系统。你可以编译为你喜欢的模块系统。 为什么？模块就是未来，让我们开始迈向未来吧。 // bad const AirbnbStyleGuide = require('./AirbnbStyleGuide'); module.exports = AirbnbStyleGuide.es6; // ok import AirbnbStyleGuide from './AirbnbStyleGuide'; export default AirbnbStyleGuide.es6; // best import { es6 } from './AirbnbStyleGuide'; export default es6; 10.2 不要使用通配符 import。 为什么？这样能确保你只有一个默认 export。 // bad import * as AirbnbStyleGuide from './AirbnbStyleGuide'; // good import AirbnbStyleGuide from './AirbnbStyleGuide'; 10.3 不要从 import 中直接 export。 为什么？虽然一行代码简洁明了，但让 import 和 export 各司其职让事情能保持一致。 // bad // filename es6.js export { es6 as default } from './airbnbStyleGuide'; // good // filename es6.js import { es6 } from './AirbnbStyleGuide'; export default es6; ⬆ 返回目录 Iterators and Generators 11.1 不要使用 iterators。使用高阶函数例如 map() 和 reduce() 替代 for-of。 为什么？这加强了我们不变的规则。处理纯函数的回调值更易读，这比它带来的副作用更重要。 const numbers = [1, 2, 3, 4, 5]; // bad let sum = 0; for (let num of numbers) { sum += num; } sum === 15; // good let sum = 0; numbers.forEach((num) => sum += num); sum === 15; // best (use the functional force) const sum = numbers.reduce((total, num) => total + num, 0); sum === 15; 11.2 现在还不要使用 generators。 为什么？因为它们现在还没法很好地编译到 ES5。 (译者注：目前(2016/03) Chrome 和 Node.js 的稳定版本都已支持 generators) ⬆ 返回目录 属性 12.1 使用 . 来访问对象的属性。 const luke = { jedi: true, age: 28, }; // bad const isJedi = luke['jedi']; // good const isJedi = luke.jedi; 12.2 当通过变量访问属性时使用中括号 []。 const luke = { jedi: true, age: 28, }; function getProp(prop) { return luke[prop]; } const isJedi = getProp('jedi'); ⬆ 返回目录 变量 13.1 一直使用 const 来声明变量，如果不这样做就会产生全局变量。我们需要避免全局命名空间的污染。地球队长已经警告过我们了。（译注：全局，global 亦有全球的意思。地球队长的责任是保卫地球环境，所以他警告我们不要造成「全球」污染。） // bad superPower = new SuperPower(); // good const superPower = new SuperPower(); 13.2 使用 const 声明每一个变量。 为什么？增加新变量将变的更加容易，而且你永远不用再担心调换错 ; 跟 ,。 // bad const items = getItems(), goSportsTeam = true, dragonball = 'z'; // bad // (compare to above, and try to spot the mistake) const items = getItems(), goSportsTeam = true; dragonball = 'z'; // good const items = getItems(); const goSportsTeam = true; const dragonball = 'z'; 13.3 将所有的 const 和 let 分组 为什么？当你需要把已赋值变量赋值给未赋值变量时非常有用。 // bad let i, len, dragonball, items = getItems(), goSportsTeam = true; // bad let i; const items = getItems(); let dragonball; const goSportsTeam = true; let len; // good const goSportsTeam = true; const items = getItems(); let dragonball; let i; let length; 13.4 在你需要的地方给变量赋值，但请把它们放在一个合理的位置。 为什么？let 和 const 是块级作用域而不是函数作用域。 // good function() { test(); console.log('doing stuff..'); //..other stuff.. const name = getName(); if (name === 'test') { return false; } return name; } // bad - unnecessary function call function(hasName) { const name = getName(); if (!hasName) { return false; } this.setFirstName(name); return true; } // good function(hasName) { if (!hasName) { return false; } const name = getName(); this.setFirstName(name); return true; } ⬆ 返回目录 Hoisting 14.1 var 声明会被提升至该作用域的顶部，但它们赋值不会提升。let 和 const 被赋予了一种称为「暂时性死区（Temporal Dead Zones, TDZ）」的概念。这对于了解为什么 type of 不再安全相当重要。 // 我们知道这样运行不了 // （假设 notDefined 不是全局变量） function example() { console.log(notDefined); // => throws a ReferenceError } // 由于变量提升的原因， // 在引用变量后再声明变量是可以运行的。 // 注：变量的赋值 `true` 不会被提升。 function example() { console.log(declaredButNotAssigned); // => undefined var declaredButNotAssigned = true; } // 编译器会把函数声明提升到作用域的顶层， // 这意味着我们的例子可以改写成这样： function example() { let declaredButNotAssigned; console.log(declaredButNotAssigned); // => undefined declaredButNotAssigned = true; } // 使用 const 和 let function example() { console.log(declaredButNotAssigned); // => throws a ReferenceError console.log(typeof declaredButNotAssigned); // => throws a ReferenceError const declaredButNotAssigned = true; } 14.2 匿名函数表达式的变量名会被提升，但函数内容并不会。 function example() { console.log(anonymous); // => undefined anonymous(); // => TypeError anonymous is not a function var anonymous = function() { console.log('anonymous function expression'); }; } 14.3 命名的函数表达式的变量名会被提升，但函数名和函数函数内容并不会。 function example() { console.log(named); // => undefined named(); // => TypeError named is not a function superPower(); // => ReferenceError superPower is not defined var named = function superPower() { console.log('Flying'); }; } // the same is true when the function name // is the same as the variable name. function example() { console.log(named); // => undefined named(); // => TypeError named is not a function var named = function named() { console.log('named'); } } 14.4 函数声明的名称和函数体都会被提升。 function example() { superPower(); // => Flying function superPower() { console.log('Flying'); } } 想了解更多信息，参考 Ben Cherry 的 JavaScript Scoping & Hoisting。 ⬆ 返回目录 比较运算符和等号 15.1 优先使用 === 和 !== 而不是 == 和 !=. 15.2 条件表达式例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵守下面的规则： 对象 被计算为 true Undefined 被计算为 false Null 被计算为 false 布尔值 被计算为 布尔的值 数字 如果是 +0、-0、或 NaN 被计算为 false, 否则为 true 字符串 如果是空字符串 '' 被计算为 false，否则为 true if ([0]) { // true // An array is an object, objects evaluate to true } 15.3 使用简写。 // bad if (name !== '') { // ...stuff... } // good if (name) { // ...stuff... } // bad if (collection.length > 0) { // ...stuff... } // good if (collection.length) { // ...stuff... } 15.4 想了解更多信息，参考 Angus Croll 的 Truth Equality and JavaScript。 ⬆ 返回目录 代码块 16.1 使用大括号包裹所有的多行代码块。 // bad if (test) return false; // good if (test) return false; // good if (test) { return false; } // bad function() { return false; } // good function() { return false; } 16.2 如果通过 if 和 else 使用多行代码块，把 else 放在 if 代码块关闭括号的同一行。 // bad if (test) { thing1(); thing2(); } else { thing3(); } // good if (test) { thing1(); thing2(); } else { thing3(); } ⬆ 返回目录 注释 17.1 使用 /** ... */ 作为多行注释。包含描述、指定所有参数和返回值的类型和值。 // bad // make() returns a new element // based on the passed in tag name // // @param {String} tag // @return {Element} element function make(tag) { // ...stuff... return element; } // good /** * make() returns a new element * based on the passed in tag name * * @param {String} tag * @return {Element} element */ function make(tag) { // ...stuff... return element; } 17.2 使用 // 作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行。 // bad const active = true; // is current tab // good // is current tab const active = true; // bad function getType() { console.log('fetching type...'); // set the default type to 'no type' const type = this._type || 'no type'; return type; } // good function getType() { console.log('fetching type...'); // set the default type to 'no type' const type = this._type || 'no type'; return type; } 17.3 给注释增加 FIXME 或 TODO 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。这将有别于常见的注释，因为它们是可操作的。使用 FIXME -- need to figure this out 或者 TODO -- need to implement。 17.4 使用 // FIXME: 标注问题。 class Calculator { constructor() { // FIXME: shouldn't use a global here total = 0; } } 17.5 使用 // TODO: 标注问题的解决方式。 class Calculator { constructor() { // TODO: total should be configurable by an options param this.total = 0; } } ⬆ 返回目录 空白 18.1 使用 2 个空格作为缩进。 // bad function() { ∙∙∙∙const name; } // bad function() { ∙const name; } // good function() { ∙∙const name; } 18.2 在花括号前放一个空格。 // bad function test(){ console.log('test'); } // good function test() { console.log('test'); } // bad dog.set('attr',{ age: '1 year', breed: 'Bernese Mountain Dog', }); // good dog.set('attr', { age: '1 year', breed: 'Bernese Mountain Dog', }); 18.3 在控制语句（if、while 等）的小括号前放一个空格。在函数调用及声明中，不在函数的参数列表前加空格。 // bad if(isJedi) { fight (); } // good if (isJedi) { fight(); } // bad function fight () { console.log ('Swooosh!'); } // good function fight() { console.log('Swooosh!'); } 18.4 使用空格把运算符隔开。 // bad const x=y+5; // good const x = y + 5; 18.5 在文件末尾插入一个空行。 // bad (function(global) { // ...stuff... })(this); // bad (function(global) { // ...stuff... })(this);↵ ↵ // good (function(global) { // ...stuff... })(this);↵ 18.5 在使用长方法链时进行缩进。使用前面的点 . 强调这是方法调用而不是新语句。 // bad $('#items').find('.selected').highlight().end().find('.open').updateCount(); // bad $('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount(); // good $('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount(); // bad const leds = stage.selectAll('.led').data(data).enter().append('svg:svg').class('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led); // good const leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .classed('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led); 18.6 在块末和新语句前插入空行。 // bad if (foo) { return bar; } return baz; // good if (foo) { return bar; } return baz; // bad const obj = { foo() { }, bar() { }, }; return obj; // good const obj = { foo() { }, bar() { }, }; return obj; ⬆ 返回目录 逗号 19.1 行首逗号：不需要。 // bad const story = [ once , upon , aTime ]; // good const story = [ once, upon, aTime, ]; // bad const hero = { firstName: 'Ada' , lastName: 'Lovelace' , birthYear: 1815 , superPower: 'computers' }; // good const hero = { firstName: 'Ada', lastName: 'Lovelace', birthYear: 1815, superPower: 'computers', }; 19.2 增加结尾的逗号: 需要。 为什么? 这会让 git diffs 更干净。另外，像 babel 这样的转译器会移除结尾多余的逗号，也就是说你不必担心老旧浏览器的尾逗号问题。 // bad - git diff without trailing comma const hero = { firstName: 'Florence', - lastName: 'Nightingale' + lastName: 'Nightingale', + inventorOf: ['coxcomb graph', 'modern nursing'] } // good - git diff with trailing comma const hero = { firstName: 'Florence', lastName: 'Nightingale', + inventorOf: ['coxcomb chart', 'modern nursing'], } // bad const hero = { firstName: 'Dana', lastName: 'Scully' }; const heroes = [ 'Batman', 'Superman' ]; // good const hero = { firstName: 'Dana', lastName: 'Scully', }; const heroes = [ 'Batman', 'Superman', ]; ⬆ 返回目录 分号 20.1 使用分号 // bad (function() { const name = 'Skywalker' return name })() // good (() => { const name = 'Skywalker'; return name; })(); // good (防止函数在两个 IIFE 合并时被当成一个参数) ;(() => { const name = 'Skywalker'; return name; })(); Read more. ⬆ 返回目录 类型转换 21.1 在语句开始时执行类型转换。 21.2 字符串： // => this.reviewScore = 9; // bad const totalScore = this.reviewScore + ''; // good const totalScore = String(this.reviewScore); 21.3 对数字使用 parseInt 转换，并带上类型转换的基数。 const inputValue = '4'; // bad const val = new Number(inputValue); // bad const val = +inputValue; // bad const val = inputValue >> 0; // bad const val = parseInt(inputValue); // good const val = Number(inputValue); // good const val = parseInt(inputValue, 10); 21.4 如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决性能问题时，留个注释说清楚原因和你的目的。 // good /** * 使用 parseInt 导致我的程序变慢， * 改成使用位操作转换数字快多了。 */ const val = inputValue >> 0; 21.5 注: 小心使用位操作运算符。数字会被当成 64 位值，但是位操作运算符总是返回 32 位的整数（参考）。位操作处理大于 32 位的整数值时还会导致意料之外的行为。关于这个问题的讨论。最大的 32 位整数是 2,147,483,647： 2147483647 >> 0 //=> 2147483647 2147483648 >> 0 //=> -2147483648 2147483649 >> 0 //=> -2147483647 21.6 布尔: const age = 0; // bad const hasAge = new Boolean(age); // good const hasAge = Boolean(age); // good const hasAge = !!age; ⬆ 返回目录 命名规则 22.1 避免单字母命名。命名应具备描述性。 // bad function q() { // ...stuff... } // good function query() { // ..stuff.. } 22.2 使用驼峰式命名对象、函数和实例。 // bad const OBJEcttsssss = {}; const this_is_my_object = {}; function c() {} // good const thisIsMyObject = {}; function thisIsMyFunction() {} 22.3 使用帕斯卡式命名构造函数或类。 // bad function user(options) { this.name = options.name; } const bad = new user({ name: 'nope', }); // good class User { constructor(options) { this.name = options.name; } } const good = new User({ name: 'yup', }); 22.4 不要使用下划线 _ 结尾或开头来命名属性和方法。 // bad this.__firstName__ = 'Panda'; this.firstName_ = 'Panda'; this._firstName = 'Panda'; // good this.firstName = 'Panda'; 22.5 别保存 this 的引用。使用箭头函数或 Function#bind。 // bad function foo() { const self = this; return function() { console.log(self); }; } // bad function foo() { const that = this; return function() { console.log(that); }; } // good function foo() { return () => { console.log(this); }; } 22.6 如果你的文件只输出一个类，那你的文件名必须和类名完全保持一致。 // file contents class CheckBox { // ... } export default CheckBox; // in some other file // bad import CheckBox from './checkBox'; // bad import CheckBox from './check_box'; // good import CheckBox from './CheckBox'; 22.7 当你导出默认的函数时使用驼峰式命名。你的文件名必须和函数名完全保持一致。 function makeStyleGuide() { } export default makeStyleGuide; 22.8 当你导出单例、函数库、空对象时使用帕斯卡式命名。 const AirbnbStyleGuide = { es6: { } }; export default AirbnbStyleGuide; ⬆ 返回目录 存取器 23.1 属性的存取函数不是必须的。 23.2 如果你需要存取函数时使用 getVal() 和 setVal('hello')。 // bad dragon.age(); // good dragon.getAge(); // bad dragon.age(25); // good dragon.setAge(25); 23.3 如果属性是布尔值，使用 isVal() 或 hasVal()。 // bad if (!dragon.age()) { return false; } // good if (!dragon.hasAge()) { return false; } 23.4 创建 get() 和 set() 函数是可以的，但要保持一致。 class Jedi { constructor(options = {}) { const lightsaber = options.lightsaber || 'blue'; this.set('lightsaber', lightsaber); } set(key, val) { this[key] = val; } get(key) { return this[key]; } } ⬆ 返回目录 事件 24.1 当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。例如，不好的写法： // bad $(this).trigger('listingUpdated', listing.id); ... $(this).on('listingUpdated', function(e, listingId) { // do something with listingId }); 更好的写法： // good $(this).trigger('listingUpdated', { listingId : listing.id }); ... $(this).on('listingUpdated', function(e, data) { // do something with data.listingId }); ⬆ 返回目录 jQuery 25.1 使用 $ 作为存储 jQuery 对象的变量名前缀。 // bad const sidebar = $('.sidebar'); // good const $sidebar = $('.sidebar'); 25.2 缓存 jQuery 查询。 // bad function setSidebar() { $('.sidebar').hide(); // ...stuff... $('.sidebar').css({ 'background-color': 'pink' }); } // good function setSidebar() { const $sidebar = $('.sidebar'); $sidebar.hide(); // ...stuff... $sidebar.css({ 'background-color': 'pink' }); } 25.3 对 DOM 查询使用层叠 $('.sidebar ul') 或 父元素 > 子元素 $('.sidebar > ul')。 jsPerf 25.4 对有作用域的 jQuery 对象查询使用 find。 // bad $('ul', '.sidebar').hide(); // bad $('.sidebar').find('ul').hide(); // good $('.sidebar ul').hide(); // good $('.sidebar > ul').hide(); // good $sidebar.find('ul').hide(); ⬆ 返回目录 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/vue.html":{"url":"client/vue.html","title":"Vue编码规范","keywords":"","body":"Vue.js 编码规范 目标 本规范提供了一种统一的编码规范来编写 Vue.js 代码。这使得代码具有如下的特性： 其它开发者或是团队成员更容易阅读和理解。 IDEs 更容易理解代码，从而提供高亮、格式化等辅助功能 更容易使用现有的工具 更容易实现缓存以及代码包的分拆 目录 基于模块开发 vue 组件命名 组件表达式简单化 组件 props 原子化 验证组件的 props 将 this 赋值给 component 变量 组件结构化 组件事件命名 避免 this.$parent 谨慎使用 this.$refs 使用组件名作为样式作用域空间 提供组件 API 文档 提供组件 demo 对组件文件进行代码校验 只在需要时创建组件 基于模块开发 始终基于模块的方式来构建你的 app，每一个子模块只做一件事情。 Vue.js 的设计初衷就是帮助开发者更好的开发界面模块。一个模块是应用程序中独立的一个部分。 怎么做？ 每一个 Vue 组件（等同于模块）首先)必须专注于解决一个单一的问题，独立的、可复用的、微小的 和 可测试的。 如果你的组件做了太多的事或是变得臃肿，请将其拆分成更小的组件并保持单一的原则。一般来说，尽量保证每一个文件的代码行数不要超过100行。也请保证组件可独立的运行。比较好的做法是增加一个单独的demo示例。 ↑ 回到目录 Vue 组件命名 组件的命名需遵从以下原则： 有意义的: 不过于具体，也不过于抽象 简短: 2 到 3 个单词 具有可读性: 以便于沟通交流 同时还需要注意： 必须符合自定义元素规范: 使用连字符分隔单词，切勿使用保留字。 app- 前缀作为命名空间: 如果非常通用的话可使用一个单词来命名，这样可以方便于其它项目里复用。 为什么？ 组件是通过组件名来调用的。所以组件名必须简短、富有含义并且具有可读性。 如何做？ ↑ 回到目录 组件表达式简单化 Vue.js 的表达式是 100% 的 Javascript表达式。这使得其功能性很强大，但也带来潜在的复杂性。因此，你应该尽量保持表达式的简单化。 为什么？ 复杂的行内表达式难以阅读。 行内表达式是不能够通用的，这可能会导致重复编码的问题。 IDE 基本上不能识别行内表达式语法，所以使用行内表达式 IDE 不能提供自动补全和语法校验功能。 怎么做？ 如果你发现写了太多复杂并难以阅读的行内表达式，那么可以使用 method 或是 computed 属性来替代其功能。 {{ `${year}-${month}` }} export default { computed: { month() { return this.twoDigits((new Date()).getUTCMonth() + 1); }, year() { return (new Date()).getUTCFullYear(); } }, methods: { twoDigits(num) { return ('0' + num).slice(-2); } }, }; {{ `${(new Date()).getUTCFullYear()}-${('0' + ((new Date()).getUTCMonth()+1)).slice(-2)}` }} ↑ 回到目录 组件 props 原子化 虽然 Vue.js 支持传递复杂的 JavaScript 对象通过 props 属性，但是你应该尽可能的使用原始类型的数据。尽量只使用 JavaScript 原始类型（字符串、数字、布尔值）和函数。尽量避免复杂的对象。 为什么？ 使得组件 API 清晰直观。 只使用原始类型和函数作为 props 使得组件的 API 更接近于 HTML(5) 原生元素。 其它开发者更好的理解每一个 prop 的含义、作用。 传递过于复杂的对象使得我们不能够清楚的知道哪些属性或方法被自定义组件使用，这使得代码难以重构和维护。 怎么做？ 组件的每一个属性单独使用一个 props，并且使用函数或是原始类型的值。 ↑ 回到目录 验证组件的 props 在 Vue.js 中，组件的 props 即 API，一个稳定并可预测的 API 会使得你的组件更容易被其他开发者使用。 组件 props 通过自定义标签的属性来传递。属性的值可以是 Vue.js 字符串(:attr=\"value\" 或 v-bind:attr=\"value\")或是不传。你需要保证组件的 props 能应对不同的情况。 为什么？ 验证组件 props 可以保证你的组件永远是可用的（防御性编程）。即使其他开发者并未按照你预想的方法使用时也不会出错。 怎么做？ 提供默认值。 使用 type 属性校验类型。 使用 props 之前先检查该 prop 是否存在。 export default { props: { max: { type: Number, // 这里添加了数字类型的校验 default() { return 10; }, }, min: { type: Number, default() { return 0; }, }, value: { type: Number, default() { return 4; }, }, }, }; ↑ 回到目录 将 this 赋值给 component 变量 在 Vue.js 组件上下文中，this指向了组件实例。因此当你切换到了不同的上下文时，要确保 this 指向一个可用的 component 变量。 换句话说，如果你正在使用 ES6 的话，就不要再编写 var self = this; 这样的代码了，您可以安全地使用 Vue 组件。 为什么？ 使用 ES6，就不再需要将 this 保存到一个变量中了。 一般来说，当你使用箭头函数时，会保留 this 的作用域。（译者注：箭头函数没有它自己的 this 值，箭头函数内的 this 值继承自外围作用域。） 如果你没有使用 ES6，当然也就不会使用 箭头函数 啦，那你必须将 “this” 保存到到某个变量中。这是唯一的例外。 怎么做？ export default { methods: { hello() { return 'hello'; }, printHello() { console.log(this.hello()); }, }, }; export default { methods: { hello() { return 'hello'; }, printHello() { const self = this; // 没有必要 console.log(self.hello()); }, }, }; ↑ 回到目录 组件结构化 按照一定的结构组织，使得组件便于理解。 为什么？ 导出一个清晰、组织有序的组件，使得代码易于阅读和理解。同时也便于标准化。 按首字母排序 properties、data、computed、watches 和 methods 使得这些对象内的属性便于查找。 合理组织，使得组件易于阅读。（name; extends; props, data 和 computed; components; watch 和 methods; lifecycle methods 等）。 使用 name 属性。借助于 vue devtools 可以让你更方便的测试。 合理的 CSS 结构，如 BEM 或 rscss - 详情？。 使用单文件 .vue 文件格式来组件代码。 怎么做？ 组件结构化 export default { // 不要忘记了 name 属性 name: 'RangeSlider', // 使用组件 mixins 共享通用功能 mixins: [], // 组成新的组件 extends: {}, // 组件属性、变量 props: { bar: {}, // 按字母顺序 foo: {}, fooBar: {}, }, // 变量 data() {}, computed: {}, // 使用其它组件 components: {}, // 方法 watch: {}, methods: {}, // 生命周期函数 beforeCreate() {}, mounted() {}, }; .Ranger__Wrapper { /* ... */ } ↑ 回到目录 组件事件命名 Vue.js 提供的处理函数和表达式都是绑定在 ViewModel 上的，组件的每一个事件都应该按照一个好的命名规范来，这样可以避免不少的开发问题，具体可见如下 为什么。 为什么？ 开发者可以随意给事件命名，即使是原生事件的名字，这样会带来迷惑性。 过于宽松的事件命名可能与 DOM 模板不兼容。 怎么做？ 事件名也使用连字符命名。 一个事件的名字对应组件外的一组意义操作，如：upload-success、upload-error 以及 dropzone-upload-success、dropzone-upload-error （如果需要前缀的话）。 事件命名应该以动词（如 client-api-load） 或是 名词（如 drive-upload-success）结尾。（出处） ↑ 回到目录 避免 this.$parent Vue.js 支持组件嵌套，并且子组件可访问父组件的上下文。访问组件之外的上下文违反了基于模块开发的第一原则。因此你应该尽量避免使用 this.$parent。 为什么？ 组件必须相互保持独立，Vue 组件也是。如果组件需要访问其父层的上下文就违反了该原则。 如果一个组件需要访问其父组件的上下文，那么该组件将不能在其它上下文中复用。 怎么做？ 通过 props 将值传递给子组件。 通过 props 传递回调函数给子组件来达到调用父组件方法的目的。 通过在子组件触发事件来通知父组件。 ↑ 回到目录 谨慎使用 this.$refs Vue.js 支持通过 ref 属性来访问其它组件和 HTML 元素。并通过 this.$refs 可以得到组件或 HTML 元素的上下文。在大多数情况下，通过 this.$refs来访问其它组件的上下文是可以避免的。在使用的的时候你需要注意避免调用了不恰当的组件 API，所以应该尽量避免使用 this.$refs。 为什么？ 组件必须是保持独立的，如果一个组件的 API 不能够提供所需的功能，那么这个组件在设计、实现上是有问题的。 组件的属性和事件必须足够的给大多数的组件使用。 怎么做？ 提供良好的组件 API。 总是关注于组件本身的目的。 拒绝定制代码。如果你在一个通用的组件内部编写特定需求的代码，那么代表这个组件的 API 不够通用，或者你可能需要一个新的组件来应对该需求。 检查所有的 props 是否有缺失的，如果有提一个 issue 或是完善这个组件。 检查所有的事件。子组件向父组件通信一般是通过事件来实现的，但是大多数的开发者更多的关注于 props 从忽视了这点。 Props向下传递，事件向上传递！。以此为目标升级你的组件，提供良好的 API 和 独立性。 当遇到 props 和 events 难以实现的功能时，通过 this.$refs来实现。 当需要操作 DOM 无法通过指令来做的时候可使用 this.$ref 而不是 JQuery、document.getElement*、document.queryElement。 Basic Modal Close Open modal export default { // ... data() { return { active: false, }; }, methods: { open() { this.active = true; }, hide() { this.active = false; }, }, // ... }; export default { // ... methods: { getRangeCurrentValue() { return this.$refs.range.currentValue; }, }, // ... }; ↑ 回到目录 使用组件名作为样式作用域空间 Vue.js 的组件是自定义元素，这非常适合用来作为样式的根作用域空间。可以将组件名作为 CSS 类的命名空间。 为什么？ 给样式加上作用域空间可以避免组件样式影响外部的样式。 保持模块名、目录名、样式根作用域名一样，可以很好的将其关联起来，便于开发者理解。 怎么做？ 使用组件名作为样式命名的前缀，可基于 BEM 或 OOCSS 范式。同时给 style 标签加上 scoped 属性。加上 scoped 属性编译后会给组件的 class 自动加上唯一的前缀从而避免样式的冲突。 /* 推荐 */ .MyExample { } .MyExample li { } .MyExample__item { } /* 避免 */ .My-Example { } /* 没有用组件名或模块名限制作用域, 不符合 BEM 规范 */ ↑ 回到目录 提供组件 API 文档 使用 Vue.js 组件的过程中会创建 Vue 组件实例，这个实例是通过自定义属性配置的。为了便于其他开发者使用该组件，对于这些自定义属性即组件API应该在 README.md 文件中进行说明。 为什么？ 良好的文档可以让开发者比较容易的对组件有一个整体的认识，而不用去阅读组件的源码，也更方便开发者使用。 组件配置属性即组件的 API，对于组件的用户来说他们更感兴趣的是 API 而不是实现原理。 正式的文档会告诉开发者组件 API 变更以及向后的兼容性情况。 README.md 是标准的我们应该首先阅读的文档文件。代码托管网站（GitHub、Bitbucket、Gitlab 等）会默认在仓库中展示该文件作为仓库的介绍。 怎么做？ 在模块目录中添加 README.md 文件： range-slider/ ├── range-slider.vue ├── range-slider.less └── README.md 在 README 文件中说明模块的功能以及使用场景。对于 vue 组件来说，比较有用的描述是组件的自定义属性即 API 的描述介绍。 Range slider 功能 range slider 组件可通过拖动的方式来设置一个给定范围内的数值。 该模块使用 noUiSlider 来实现跨浏览器和 touch 功能的支持。 如何使用 支持如下的自定义属性： attribute type description min Number 可拖动的最小值. max Number 可拖动的最大值. values Number[] optional 包含最大值和最小值的数组. 如. values=\"[10, 20]\". Defaults to [opts.min, opts.max]. step Number optional 增加减小的数值单位，默认为 1. on-slide Function optional 用户拖动开始按钮或者结束按钮时的回调函数，函数接受 (values, HANDLE) 格式的参数。 如： on-slide={ updateInputs }, component.updateInputs = (values, HANDLE) => { const value = values[HANDLE]; }. on-end Function optional 当用户停止拖动时触发的回调函数，函数接受 (values, HANDLE) 格式的参数。 如需要自定义 slider 的样式可参考 noUiSlider 文档) ↑ 回到目录 提供组件 demo 添加 index.html 文件作为组件的 demo 示例，并提供不同配置情况的效果，说明组件是如何使用的。 为什么？ demo 可以说明组件是独立可使用的。 demo 可以让开发者预览组件的功能效果。 demo 可以展示组件各种配置参数下的功能。 ↑ 回到目录 对组件文件进行代码校验 代码校验可以保持代码的统一性以及追踪语法错误。.vue 文件可以通过使用 eslint插件来校验代码。 为什么？ 保证所有的开发者使用同样的编码规范。 更早的感知到语法错误。 怎么做？ 为了校验工具能够校验 *.vue文件，你需要将代码编写在 标签中，并使组件表达式简单化，因为校验工具无法理解行内表达式，配置校验工具可以访问全局变量 vue 和组件的 props。 ESLint 具体配置可参考【开发工具】。 只在需要时创建组件 为什么？ Vue.js 是一个基于组件的框架。如果你不知道何时创建组件可能会导致以下问题： 如果组件太大, 可能很难重用和维护; 如果组件太小，你的项目就会（因为深层次的嵌套而）被淹没，也更难使组件间通信; 怎么做? 始终记住为你的项目需求构建你的组件，但是你也应该尝试想到它们能够从中脱颖而出（独立于项目之外）。如果它们能够在你项目之外工作，就像一个库那样，就会使得它们更加健壮和一致。 尽可能早地构建你的组件总是更好的，因为这样使得你可以在一个已经存在和稳定的组件上构建你的组件间通信（props & events）。 规则 首先，尽可能早地尝试构建出诸如模态框、提示框、工具条、菜单、头部等这些明显的（通用型）组件。总之，你知道的这些组件以后一定会在当前页面或者是全局范围内需要。 第二，在每一个新的开发项目中，对于一整个页面或者其中的一部分，在进行开发前先尝试思考一下。如果你认为它有一部分应该是一个组件，那么就创建它吧。 最后，如果你不确定，那就不要。避免那些“以后可能会有用”的组件污染你的项目。它们可能会永远的只是（静静地）待在那里，这一点也不聪明。注意，一旦你意识到应该这么做，最好是就把它打破，以避免与项目的其他部分构成兼容性和复杂性。 ↑ 回到目录 尽可能使用 mixins 为什么? Mixins 封装可重用的代码，避免了重复。如果两个组件共享有相同的功能，则可以使用 mixin。通过 mixin，你可以专注于单个组件的任务和抽象的通用代码。这有助于更好地维护你的应用程序。 怎么做? 假设你有一个移动端和桌面端的菜单组件，它们共享一些功能。我们可以抽象出这两个组件的核心功能到一个 mixin 中，例如： const MenuMixin = { data () { return { language: 'EN' } }, methods: { changeLanguage () { if (this.language === 'DE') this.$set(this, 'language', 'EN') if (this.language === 'EN') this.$set(this, 'language', 'DE') } } } export default MenuMixin 要使用 mixin，只需将其导入到两个组件中（我只展示移动组件）。 Change language import MenuMixin from './MenuMixin' export default { mixins: [MenuMixin] } ↑ 回到目录 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"client/webpack.html":{"url":"client/webpack.html","title":"前端构建工具webpack","keywords":"","body":"前端构建工具webpack Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "},"server/introduction.html":{"url":"server/introduction.html","title":"简介","keywords":"","body":"简介 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-13 08:43:35 "}}