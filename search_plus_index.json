{"./":{"url":"./","title":"简介","keywords":"","body":"介绍 此手册主要实现的目标：代码一致性和最佳实践。通过代码风格的一致性，降低维护代码的成本以及改善多人协作的效率。同时遵守最佳实践，确保页面性能得到最佳优化和高效的代码。 此手册是在开发中积累下来的经验和参考其它规范/指南制定的，它只是起指导作用，除个别条目强制之外，大多数为非强制约束，开发者可根据自己的实际情况自行决定是否要遵守 该指南只是保证大方向一致性和最佳实践的阶段性总结，不是最后结论，它会随着时间而变化。 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-12 09:55:09 "},"basic/gitbook.html":{"url":"basic/gitbook.html","title":"GitBook使用","keywords":"","body":"GitBook的使用 环境准备 gitbook 的安装非常简单，详细指南可以参考 gitbook 文档。 这里的安装只需要一步就能完成！ $ npm install gitbook gitbook-cli -g 需要注意的是：用户首先需要安装 nodejs，以便能够使用 npm 来安装 gitbook。 gitbook用法 gitbook 的基本用法非常简单，基本上就只有三步： 使用 gitbook install 来安装项目依赖 使用 gitbook init 初始化书籍目录，它会为我们创建 SUMMARY.md 中的文件夹及对应文件。 使用 gitbook serve 编译和预览书籍 $ gitbook serve Press CTRL+C to quit ... Live reload server started on port: 35729 Starting build ... Successfully built! Starting server ... Serving book on http://localhost:4000 目录介绍 README.md 和 SUMMARY.md 是两个必须文件 / ├── README.md // 书籍的简单介绍 └── SUMMARY.md // 书籍的目录结构 SUMMARY.md 是书籍的目录结构。内容如下： # Summary ## 简介 * [简介](README.md) ## 快速上手 * [GitBook使用](basic/gitbook.md) * [Markdown](basic/markdown.md) * [文档编写](basic/document.md) * [持续集成](basic/building.md) ## 前端规范 * [基本原则](front/principle.md) * [开发工具](front/devtool.md) * [HTML](front/html.md) * [通用约定](front/html/general.md) * [语义化](front/html/semantization.md) * [HEAD](front/html/head.md) * [CSS](front/css.md) * [JavaScript](front/javascript.md) * [Vue](front/vue.md) * [ES6](front/es6-style-guide.md) 文档编写使用MarkDown，请查看下步。 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-12 09:55:09 "},"basic/markdown.html":{"url":"basic/markdown.html","title":"Markdown","keywords":"","body":"Markdown Markdown 是一种轻量级标记语言，它用简洁的语法代替排版，使我们专心于码字。 它的目标是实现易读易写，成为一种适用于网络的书写语言。同时，Markdown支持嵌入html标签。 注意：Markdown使用#、+、*等符号来标记， 符号后面必须跟上 至少1个 空格才有效！ 工欲善其事，必先利其器 MarkDown可选编辑器： Sublime text 3 (需要安装 MarkdownEditing 插件。) Visual Studio Code MarkDown基本语法 目录 标题 列表 引用 强调 转义 图片与链接 代码 分隔线 换行 脚注(注解) 表格 标题 用#标记，在 标题开头 加上1~6个#，依次代表一级标题、二级标题....六级标题 # 一级标题 ## 二级标题 ### 三级标题 ##### 四级标题 ###### 五级标题 ###### 六级标题 效果如下： 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 ↑ 回到目录 列表 Markdown 支持有序列表和无序列表。 无序列表使用-、+和*作为列表标记： - Red * Green + Blue 效果如下： Red Green Blue 有序列表则使用数字加英文句点.来表示： 1. Red 2. Green 3. Blue 效果如下： Red Green Blue 列表嵌套 1. one 1. one-1 2. two-2 2. two * two-1 * two-2 one one-1 two-2 two two-1 two-2 列表嵌套代码块注：换行+Tab * one var a = 10; // 与上行保持空行并 递进缩进 one var a = 10; // 与上行保持空行并 递进缩进 ↑ 回到目录 引用 引用以>来表示，引用中支持多级引用、标题、列表、代码块、分割线等常规语法。 常见的引用写法： > 这是一段引用 //在`>`后面有 1 个空格 > > 这是引用的代码块形式 //在`>`后面有 5 个空格 > > 代码例子： > protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } > 一级引用 >> 二级引用 >>> 三级引用 > > 1. 这是第一行列表项 > 2. 这是第二行列表项 效果如下： 这是一段引用 //在>后面有 1 个空格 这是引用的代码块形式 //在`>`后面有 5 个空格 代码例子： protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } 一级引用 二级引用 三级引用 这是第一行列表项 这是第二行列表项 ↑ 回到目录 强调 两个*或_代表加粗，一个*或_代表斜体，~~代表删除。 **加粗文本** 或者 __加粗文本__ *斜体文本* 或者_斜体文本_ ~~删除文本~~ 效果如下： 加粗文本 或者 加粗文本 斜体文本 或者 斜体文本 删除文本 ↑ 回到目录 转义 使用\\来插入一些在语法中有其它意义的符号，如*。 \\\\ 反斜线 \\` 反引号 \\* 星号 \\_ 底线 \\{\\} 花括号 \\[\\] 方括号 \\(\\) 括弧 \\# 井字号 \\+ 加号 \\- 减号 \\. 英文句点 \\! 惊叹号 演示： \\ 反斜线` 反引号 * 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 ↑ 回到目录 图片与链接 图片与链接的语法很像，区别在一个 ! 号。二者格式： 图片：![]() ![图片文本(可忽略)](图片地址) 图片带有链接：[![](../imgs/img.png '百度')](http://www.baidu.com) [![图片文本(可忽略)](图片地址)](链接地址) 链接：[]() [链接文本](链接地址) 图片演示： 图片带有链接： 链接演示： 美女在这里 ↑ 回到目录 代码 代码分为行内代码和代码块。 行内代码使用一对 ` 标识，可嵌入文字。 代码块使用一对```标识，可嵌入代码。这里是代码块 代码语法高亮在 ```后面加上空格和语言名称即可protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } ↑ 回到目录 分隔线 在一行中用三个以上的*、-、_来建立一个分隔线，行内不能有其他东西。也可以在符号间插入空格。这里推荐使用-。 *** --- ___ * * * 效果均为一条分割线： ↑ 回到目录 换行 在行尾添加两个空格加回车表示换行： 这是一行后面加两个空格 换行 效果如下： 这是一行后面加两个空格换行 ↑ 回到目录 脚注 使用来定义脚注： Markdown[^1] [^1]: Markdown是一种纯文本标记语言 效果如下： Markdown1 1. Markdown是一种纯文本标记语言 ↩ ↑ 回到目录 表格 注： : 代表对齐方式，: 与 | 之间不要有空格，否则对齐会有些不兼容 | a | b | c | |:-------:|:------------- | ----------:| | 居中 | 左对齐 | 右对齐 | |=========|===============|============| 演示： a b c 居中 左对齐 右对齐 ========= =============== ============ ↑ 回到目录 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-12 09:55:09 "},"front/principle.html":{"url":"front/principle.html","title":"基本原则","keywords":"","body":"规范说明 此为前端开发团队遵循和约定的代码书写规范，意在提高代码的规范性和可维护性，统一团队编码规范和风格。让所有代码都是有规可循的，并且能够得到沉淀，减少重复劳动。 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-12 09:55:09 "},"front/devtool.html":{"url":"front/devtool.html","title":"开发工具","keywords":"","body":"前端开发工具 Visual Studio Code简介 Visual Studio Code（以下简称vscode）是一个轻量且强大的代码编辑器，支持Windows，OS X和Linux。内置JavaScript、TypeScript和Node.js支持，而且拥有丰富的插件生态系统，可通过安装插件来支持C++、C#、Python、PHP等其他语言。 推荐插件 Auto Close Tag（修改 html 标签，自动帮你完成尾部闭合标签的同步修改） vscode-icon （让 vscode 资源树目录加上图标，必备良品！） Debugger for Chrome （） Path Intellisense （自动路劲补全，默认不带这个功能的） ESlint （ESlint 接管原生 js 提示，可以自定制提示规则） 首先安装vscode的插件 ESLint 在vscode设置里添加 \"eslint.validate\": [ \"javascript\", \"javascriptreact\", \"html\", { \"language\": \"html\", \"autoFix\": true }, { \"language\": \"vue\", \"autoFix\": true } ], \"eslint.autoFixOnSave\": true 在项目根目录下创建 .eslintrc.js 文件，内容如下： module.exports = { root: true, parser: 'babel-eslint', parserOptions: { sourceType: 'module' }, env: { browser: true, node: true, es6: true }, extends: 'eslint:recommended', // required to lint *.vue files plugins: ['html'], // check if imports actually resolve settings: { 'import/resolver': { webpack: { config: 'build/webpack.base.conf.js' } } }, // add your custom rules here //it is base on https://github.com/vuejs/eslint-config-vue rules: { 'accessor-pairs': 2, 'arrow-spacing': [ 2, { before: true, after: true } ], 'block-spacing': [2, 'always'], 'brace-style': [ 2, '1tbs', { allowSingleLine: true } ], camelcase: [ 0, { properties: 'always' } ], 'comma-dangle': [2, 'never'], 'comma-spacing': [ 2, { before: false, after: true } ], 'comma-style': [2, 'last'], 'constructor-super': 2, curly: [2, 'multi-line'], 'dot-location': [2, 'property'], 'eol-last': 2, eqeqeq: [2, 'allow-null'], 'generator-star-spacing': [ 2, { before: true, after: true } ], 'handle-callback-err': [2, '^(err|error)$'], indent: [ 2, 2, { SwitchCase: 1 } ], 'jsx-quotes': [2, 'prefer-single'], 'key-spacing': [ 2, { beforeColon: false, afterColon: true } ], 'keyword-spacing': [ 2, { before: true, after: true } ], 'new-cap': [ 2, { newIsCap: true, capIsNew: false } ], 'new-parens': 2, 'no-array-constructor': 2, 'no-caller': 2, 'no-console': 'off', 'no-class-assign': 2, 'no-cond-assign': 2, 'no-const-assign': 2, 'no-control-regex': 0, 'no-delete-var': 2, 'no-dupe-args': 2, 'no-dupe-class-members': 2, 'no-dupe-keys': 2, 'no-duplicate-case': 2, 'no-empty-character-class': 2, 'no-empty-pattern': 2, 'no-eval': 2, 'no-ex-assign': 2, 'no-extend-native': 2, 'no-extra-bind': 2, 'no-extra-boolean-cast': 2, 'no-extra-parens': [2, 'functions'], 'no-fallthrough': 2, 'no-floating-decimal': 2, 'no-func-assign': 2, 'no-implied-eval': 2, 'no-inner-declarations': [2, 'functions'], 'no-invalid-regexp': 2, 'no-irregular-whitespace': 2, 'no-iterator': 2, 'no-label-var': 2, 'no-labels': [ 2, { allowLoop: false, allowSwitch: false } ], 'no-lone-blocks': 2, 'no-mixed-spaces-and-tabs': 2, 'no-multi-spaces': 2, 'no-multi-str': 2, 'no-multiple-empty-lines': [ 2, { max: 1 } ], 'no-native-reassign': 2, 'no-negated-in-lhs': 2, 'no-new-object': 2, 'no-new-require': 2, 'no-new-symbol': 2, 'no-new-wrappers': 2, 'no-obj-calls': 2, 'no-octal': 2, 'no-octal-escape': 2, 'no-path-concat': 2, 'no-proto': 2, 'no-redeclare': 2, 'no-regex-spaces': 2, 'no-return-assign': [2, 'except-parens'], 'no-self-assign': 2, 'no-self-compare': 2, 'no-sequences': 2, 'no-shadow-restricted-names': 2, 'no-spaced-func': 2, 'no-sparse-arrays': 2, 'no-this-before-super': 2, 'no-throw-literal': 2, 'no-trailing-spaces': 2, 'no-undef': 2, 'no-undef-init': 2, 'no-unexpected-multiline': 2, 'no-unmodified-loop-condition': 2, 'no-unneeded-ternary': [ 2, { defaultAssignment: false } ], 'no-unreachable': 2, 'no-unsafe-finally': 2, 'no-unused-vars': [ 2, { vars: 'all', args: 'none' } ], 'no-useless-call': 2, 'no-useless-computed-key': 2, 'no-useless-constructor': 2, 'no-useless-escape': 0, 'no-whitespace-before-property': 2, 'no-with': 2, 'one-var': [ 2, { initialized: 'never' } ], 'operator-linebreak': [ 2, 'after', { overrides: { '?': 'before', ':': 'before' } } ], 'padded-blocks': [2, 'never'], quotes: [ 2, 'single', { avoidEscape: true, allowTemplateLiterals: true } ], semi: [2, 'never'], 'semi-spacing': [ 2, { before: false, after: true } ], 'space-before-blocks': [2, 'always'], 'space-before-function-paren': [2, 'never'], 'space-in-parens': [2, 'never'], 'space-infix-ops': 2, 'space-unary-ops': [ 2, { words: true, nonwords: false } ], 'spaced-comment': [ 2, 'always', { markers: ['global', 'globals', 'eslint', 'eslint-disable', '*package', '!', ','] } ], 'template-curly-spacing': [2, 'never'], 'use-isnan': 2, 'valid-typeof': 2, 'wrap-iife': [2, 'any'], 'yield-star-spacing': [2, 'both'], yoda: [2, 'never'], 'prefer-const': 2, 'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0, 'object-curly-spacing': [ 2, 'always', { objectsInObjects: false } ], 'array-bracket-spacing': [2, 'never'] } } Prettier （前端的代码格式化工具） 首先安装vscode的插件 Prettier 和 vetur 在vscode设置里添加\"vetur.format.defaultFormatter.html\":\"js-beautify-html\" Vetur （Vue工具） 主题 One Dark Pro (漂亮！) Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-12 09:55:09 "},"front/html.html":{"url":"front/html.html","title":"HTML","keywords":"","body":"HTML Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-12 09:55:09 "},"front/html/general.html":{"url":"front/html/general.html","title":"通用约定","keywords":"","body":"通用约定 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-12 09:55:09 "},"front/html/semantization.html":{"url":"front/html/semantization.html","title":"语义化","keywords":"","body":"语义化 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-12 09:55:09 "},"front/html/head.html":{"url":"front/html/head.html","title":"HEAD","keywords":"","body":"HEAD Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-12 09:55:09 "},"front/css.html":{"url":"front/css.html","title":"CSS","keywords":"","body":"CSS Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-12 09:55:09 "},"front/javascript.html":{"url":"front/javascript.html","title":"JavaScript","keywords":"","body":"JavaScript Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-12 09:55:09 "},"front/vue.html":{"url":"front/vue.html","title":"Vue","keywords":"","body":"Vue.js 编码规范 目标 本规范提供了一种统一的编码规范来编写 Vue.js 代码。这使得代码具有如下的特性： 其它开发者或是团队成员更容易阅读和理解。 IDEs 更容易理解代码，从而提供高亮、格式化等辅助功能 更容易使用现有的工具 更容易实现缓存以及代码包的分拆 目录 基于模块开发 vue 组件命名 组件表达式简单化 组件 props 原子化 验证组件的 props 将 this 赋值给 component 变量 组件结构化 组件事件命名 避免 this.$parent 谨慎使用 this.$refs 使用组件名作为样式作用域空间 提供组件 API 文档 提供组件 demo 对组件文件进行代码校验 只在需要时创建组件 基于模块开发 始终基于模块的方式来构建你的 app，每一个子模块只做一件事情。 Vue.js 的设计初衷就是帮助开发者更好的开发界面模块。一个模块是应用程序中独立的一个部分。 怎么做？ 每一个 Vue 组件（等同于模块）首先)必须专注于解决一个单一的问题，独立的、可复用的、微小的 和 可测试的。 如果你的组件做了太多的事或是变得臃肿，请将其拆分成更小的组件并保持单一的原则。一般来说，尽量保证每一个文件的代码行数不要超过100行。也请保证组件可独立的运行。比较好的做法是增加一个单独的demo示例。 ↑ 回到目录 Vue 组件命名 组件的命名需遵从以下原则： 有意义的: 不过于具体，也不过于抽象 简短: 2 到 3 个单词 具有可读性: 以便于沟通交流 同时还需要注意： 必须符合自定义元素规范: 使用连字符分隔单词，切勿使用保留字。 app- 前缀作为命名空间: 如果非常通用的话可使用一个单词来命名，这样可以方便于其它项目里复用。 为什么？ 组件是通过组件名来调用的。所以组件名必须简短、富有含义并且具有可读性。 如何做？ ↑ 回到目录 组件表达式简单化 Vue.js 的表达式是 100% 的 Javascript表达式。这使得其功能性很强大，但也带来潜在的复杂性。因此，你应该尽量保持表达式的简单化。 为什么？ 复杂的行内表达式难以阅读。 行内表达式是不能够通用的，这可能会导致重复编码的问题。 IDE 基本上不能识别行内表达式语法，所以使用行内表达式 IDE 不能提供自动补全和语法校验功能。 怎么做？ 如果你发现写了太多复杂并难以阅读的行内表达式，那么可以使用 method 或是 computed 属性来替代其功能。 {{ `${year}-${month}` }} export default { computed: { month() { return this.twoDigits((new Date()).getUTCMonth() + 1); }, year() { return (new Date()).getUTCFullYear(); } }, methods: { twoDigits(num) { return ('0' + num).slice(-2); } }, }; {{ `${(new Date()).getUTCFullYear()}-${('0' + ((new Date()).getUTCMonth()+1)).slice(-2)}` }} ↑ 回到目录 组件 props 原子化 虽然 Vue.js 支持传递复杂的 JavaScript 对象通过 props 属性，但是你应该尽可能的使用原始类型的数据。尽量只使用 JavaScript 原始类型（字符串、数字、布尔值）和函数。尽量避免复杂的对象。 为什么？ 使得组件 API 清晰直观。 只使用原始类型和函数作为 props 使得组件的 API 更接近于 HTML(5) 原生元素。 其它开发者更好的理解每一个 prop 的含义、作用。 传递过于复杂的对象使得我们不能够清楚的知道哪些属性或方法被自定义组件使用，这使得代码难以重构和维护。 怎么做？ 组件的每一个属性单独使用一个 props，并且使用函数或是原始类型的值。 ↑ 回到目录 验证组件的 props 在 Vue.js 中，组件的 props 即 API，一个稳定并可预测的 API 会使得你的组件更容易被其他开发者使用。 组件 props 通过自定义标签的属性来传递。属性的值可以是 Vue.js 字符串(:attr=\"value\" 或 v-bind:attr=\"value\")或是不传。你需要保证组件的 props 能应对不同的情况。 为什么？ 验证组件 props 可以保证你的组件永远是可用的（防御性编程）。即使其他开发者并未按照你预想的方法使用时也不会出错。 怎么做？ 提供默认值。 使用 type 属性校验类型。 使用 props 之前先检查该 prop 是否存在。 export default { props: { max: { type: Number, // 这里添加了数字类型的校验 default() { return 10; }, }, min: { type: Number, default() { return 0; }, }, value: { type: Number, default() { return 4; }, }, }, }; ↑ 回到目录 将 this 赋值给 component 变量 在 Vue.js 组件上下文中，this指向了组件实例。因此当你切换到了不同的上下文时，要确保 this 指向一个可用的 component 变量。 换句话说，如果你正在使用 ES6 的话，就不要再编写 var self = this; 这样的代码了，您可以安全地使用 Vue 组件。 为什么？ 使用 ES6，就不再需要将 this 保存到一个变量中了。 一般来说，当你使用箭头函数时，会保留 this 的作用域。（译者注：箭头函数没有它自己的 this 值，箭头函数内的 this 值继承自外围作用域。） 如果你没有使用 ES6，当然也就不会使用 箭头函数 啦，那你必须将 “this” 保存到到某个变量中。这是唯一的例外。 怎么做？ export default { methods: { hello() { return 'hello'; }, printHello() { console.log(this.hello()); }, }, }; export default { methods: { hello() { return 'hello'; }, printHello() { const self = this; // 没有必要 console.log(self.hello()); }, }, }; ↑ 回到目录 组件结构化 按照一定的结构组织，使得组件便于理解。 为什么？ 导出一个清晰、组织有序的组件，使得代码易于阅读和理解。同时也便于标准化。 按首字母排序 properties、data、computed、watches 和 methods 使得这些对象内的属性便于查找。 合理组织，使得组件易于阅读。（name; extends; props, data 和 computed; components; watch 和 methods; lifecycle methods 等）。 使用 name 属性。借助于 vue devtools 可以让你更方便的测试。 合理的 CSS 结构，如 BEM 或 rscss - 详情？。 使用单文件 .vue 文件格式来组件代码。 怎么做？ 组件结构化 export default { // 不要忘记了 name 属性 name: 'RangeSlider', // 使用组件 mixins 共享通用功能 mixins: [], // 组成新的组件 extends: {}, // 组件属性、变量 props: { bar: {}, // 按字母顺序 foo: {}, fooBar: {}, }, // 变量 data() {}, computed: {}, // 使用其它组件 components: {}, // 方法 watch: {}, methods: {}, // 生命周期函数 beforeCreate() {}, mounted() {}, }; .Ranger__Wrapper { /* ... */ } ↑ 回到目录 组件事件命名 Vue.js 提供的处理函数和表达式都是绑定在 ViewModel 上的，组件的每一个事件都应该按照一个好的命名规范来，这样可以避免不少的开发问题，具体可见如下 为什么。 为什么？ 开发者可以随意给事件命名，即使是原生事件的名字，这样会带来迷惑性。 过于宽松的事件命名可能与 DOM 模板不兼容。 怎么做？ 事件名也使用连字符命名。 一个事件的名字对应组件外的一组意义操作，如：upload-success、upload-error 以及 dropzone-upload-success、dropzone-upload-error （如果需要前缀的话）。 事件命名应该以动词（如 client-api-load） 或是 名词（如 drive-upload-success）结尾。（出处） ↑ 回到目录 避免 this.$parent Vue.js 支持组件嵌套，并且子组件可访问父组件的上下文。访问组件之外的上下文违反了基于模块开发的第一原则。因此你应该尽量避免使用 this.$parent。 为什么？ 组件必须相互保持独立，Vue 组件也是。如果组件需要访问其父层的上下文就违反了该原则。 如果一个组件需要访问其父组件的上下文，那么该组件将不能在其它上下文中复用。 怎么做？ 通过 props 将值传递给子组件。 通过 props 传递回调函数给子组件来达到调用父组件方法的目的。 通过在子组件触发事件来通知父组件。 ↑ 回到目录 谨慎使用 this.$refs Vue.js 支持通过 ref 属性来访问其它组件和 HTML 元素。并通过 this.$refs 可以得到组件或 HTML 元素的上下文。在大多数情况下，通过 this.$refs来访问其它组件的上下文是可以避免的。在使用的的时候你需要注意避免调用了不恰当的组件 API，所以应该尽量避免使用 this.$refs。 为什么？ 组件必须是保持独立的，如果一个组件的 API 不能够提供所需的功能，那么这个组件在设计、实现上是有问题的。 组件的属性和事件必须足够的给大多数的组件使用。 怎么做？ 提供良好的组件 API。 总是关注于组件本身的目的。 拒绝定制代码。如果你在一个通用的组件内部编写特定需求的代码，那么代表这个组件的 API 不够通用，或者你可能需要一个新的组件来应对该需求。 检查所有的 props 是否有缺失的，如果有提一个 issue 或是完善这个组件。 检查所有的事件。子组件向父组件通信一般是通过事件来实现的，但是大多数的开发者更多的关注于 props 从忽视了这点。 Props向下传递，事件向上传递！。以此为目标升级你的组件，提供良好的 API 和 独立性。 当遇到 props 和 events 难以实现的功能时，通过 this.$refs来实现。 当需要操作 DOM 无法通过指令来做的时候可使用 this.$ref 而不是 JQuery、document.getElement*、document.queryElement。 Basic Modal Close Open modal export default { // ... data() { return { active: false, }; }, methods: { open() { this.active = true; }, hide() { this.active = false; }, }, // ... }; export default { // ... methods: { getRangeCurrentValue() { return this.$refs.range.currentValue; }, }, // ... }; ↑ 回到目录 使用组件名作为样式作用域空间 Vue.js 的组件是自定义元素，这非常适合用来作为样式的根作用域空间。可以将组件名作为 CSS 类的命名空间。 为什么？ 给样式加上作用域空间可以避免组件样式影响外部的样式。 保持模块名、目录名、样式根作用域名一样，可以很好的将其关联起来，便于开发者理解。 怎么做？ 使用组件名作为样式命名的前缀，可基于 BEM 或 OOCSS 范式。同时给 style 标签加上 scoped 属性。加上 scoped 属性编译后会给组件的 class 自动加上唯一的前缀从而避免样式的冲突。 /* 推荐 */ .MyExample { } .MyExample li { } .MyExample__item { } /* 避免 */ .My-Example { } /* 没有用组件名或模块名限制作用域, 不符合 BEM 规范 */ ↑ 回到目录 提供组件 API 文档 使用 Vue.js 组件的过程中会创建 Vue 组件实例，这个实例是通过自定义属性配置的。为了便于其他开发者使用该组件，对于这些自定义属性即组件API应该在 README.md 文件中进行说明。 为什么？ 良好的文档可以让开发者比较容易的对组件有一个整体的认识，而不用去阅读组件的源码，也更方便开发者使用。 组件配置属性即组件的 API，对于组件的用户来说他们更感兴趣的是 API 而不是实现原理。 正式的文档会告诉开发者组件 API 变更以及向后的兼容性情况。 README.md 是标准的我们应该首先阅读的文档文件。代码托管网站（GitHub、Bitbucket、Gitlab 等）会默认在仓库中展示该文件作为仓库的介绍。 怎么做？ 在模块目录中添加 README.md 文件： range-slider/ ├── range-slider.vue ├── range-slider.less └── README.md 在 README 文件中说明模块的功能以及使用场景。对于 vue 组件来说，比较有用的描述是组件的自定义属性即 API 的描述介绍。 Range slider 功能 range slider 组件可通过拖动的方式来设置一个给定范围内的数值。 该模块使用 noUiSlider 来实现跨浏览器和 touch 功能的支持。 如何使用 支持如下的自定义属性： attribute type description min Number 可拖动的最小值. max Number 可拖动的最大值. values Number[] optional 包含最大值和最小值的数组. 如. values=\"[10, 20]\". Defaults to [opts.min, opts.max]. step Number optional 增加减小的数值单位，默认为 1. on-slide Function optional 用户拖动开始按钮或者结束按钮时的回调函数，函数接受 (values, HANDLE) 格式的参数。 如： on-slide={ updateInputs }, component.updateInputs = (values, HANDLE) => { const value = values[HANDLE]; }. on-end Function optional 当用户停止拖动时触发的回调函数，函数接受 (values, HANDLE) 格式的参数。 如需要自定义 slider 的样式可参考 noUiSlider 文档) ↑ 回到目录 提供组件 demo 添加 index.html 文件作为组件的 demo 示例，并提供不同配置情况的效果，说明组件是如何使用的。 为什么？ demo 可以说明组件是独立可使用的。 demo 可以让开发者预览组件的功能效果。 demo 可以展示组件各种配置参数下的功能。 ↑ 回到目录 对组件文件进行代码校验 代码校验可以保持代码的统一性以及追踪语法错误。.vue 文件可以通过使用 eslint插件来校验代码。 为什么？ 保证所有的开发者使用同样的编码规范。 更早的感知到语法错误。 怎么做？ 为了校验工具能够校验 *.vue文件，你需要将代码编写在 标签中，并使组件表达式简单化，因为校验工具无法理解行内表达式，配置校验工具可以访问全局变量 vue 和组件的 props。 ESLint 具体配置可参考【开发工具】。 只在需要时创建组件 为什么？ Vue.js 是一个基于组件的框架。如果你不知道何时创建组件可能会导致以下问题： 如果组件太大, 可能很难重用和维护; 如果组件太小，你的项目就会（因为深层次的嵌套而）被淹没，也更难使组件间通信; 怎么做? 始终记住为你的项目需求构建你的组件，但是你也应该尝试想到它们能够从中脱颖而出（独立于项目之外）。如果它们能够在你项目之外工作，就像一个库那样，就会使得它们更加健壮和一致。 尽可能早地构建你的组件总是更好的，因为这样使得你可以在一个已经存在和稳定的组件上构建你的组件间通信（props & events）。 规则 首先，尽可能早地尝试构建出诸如模态框、提示框、工具条、菜单、头部等这些明显的（通用型）组件。总之，你知道的这些组件以后一定会在当前页面或者是全局范围内需要。 第二，在每一个新的开发项目中，对于一整个页面或者其中的一部分，在进行开发前先尝试思考一下。如果你认为它有一部分应该是一个组件，那么就创建它吧。 最后，如果你不确定，那就不要。避免那些“以后可能会有用”的组件污染你的项目。它们可能会永远的只是（静静地）待在那里，这一点也不聪明。注意，一旦你意识到应该这么做，最好是就把它打破，以避免与项目的其他部分构成兼容性和复杂性。 ↑ 回到目录 尽可能使用 mixins 为什么? Mixins 封装可重用的代码，避免了重复。如果两个组件共享有相同的功能，则可以使用 mixin。通过 mixin，你可以专注于单个组件的任务和抽象的通用代码。这有助于更好地维护你的应用程序。 怎么做? 假设你有一个移动端和桌面端的菜单组件，它们共享一些功能。我们可以抽象出这两个组件的核心功能到一个 mixin 中，例如： const MenuMixin = { data () { return { language: 'EN' } }, methods: { changeLanguage () { if (this.language === 'DE') this.$set(this, 'language', 'EN') if (this.language === 'EN') this.$set(this, 'language', 'DE') } } } export default MenuMixin 要使用 mixin，只需将其导入到两个组件中（我只展示移动组件）。 Change language import MenuMixin from './MenuMixin' export default { mixins: [MenuMixin] } ↑ 回到目录 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-12 09:55:09 "},"front/es6-style-guide.html":{"url":"front/es6-style-guide.html","title":"ES6","keywords":"","body":"ES6 规范 用更合理的方式写 JavaScript 目录 类型 引用 对象 数组 解构 字符串 函数 箭头函数 构造函数 模块 Iterators & Generators 属性 变量 提升 比较运算符 & 等号 代码块 注释 空白 逗号 分号 类型转换 命名规则 存取器 事件 jQuery 类型 1.1 基本类型: 直接存取基本类型。 字符串 数值 布尔类型 null undefined const foo = 1 let bar = foo bar = 9 console.log(foo, bar) // => 1, 9 1.2 复制类型: 通过引用的方式存取复杂类型。 对象 数组 函数 const foo = [1, 2] const bar = foo bar[0] = 9 console.log(foo[0], bar[0]) // => 9, 9 ⬆ 返回目录 引用 2.1 对所有的引用使用 const ；不要使用 var。 为什么？这能确保你无法对引用重新赋值，也不会导致出现 bug 或难以理解。 // bad var a = 1 var b = 2 // good const a = 1 const b = 2 2.2 如果你一定需要可变动的引用，使用 let 代替 var。 为什么？因为 let 是块级作用域，而 var 是函数作用域。 // bad var count = 1 if (true) { count += 1 } // good, use the let. let count = 1 if (true) { count += 1 } 2.3 注意 let 和 const 都是块级作用域。 // const 和 let 只存在于它们被定义的区块内。 { let a = 1 const b = 1 } console.log(a) // ReferenceError console.log(b) // ReferenceError ⬆ 返回目录 对象 3.1 使用字面值创建对象。 // bad const item = new Object(); // good const item = {}; 3.2 如果你的代码在浏览器环境下执行，别使用 保留字 作为键值。这样的话在 IE8 不会运行。 更多信息。 但在 ES6 模块和服务器端中使用没有问题。 // bad const superman = { default: { clark: 'kent' }, private: true } // good const superman = { defaults: { clark: 'kent' }, hidden: true } 3.3 使用同义词替换需要使用的保留字。 // bad const superman = { class: 'alien', } // bad const superman = { klass: 'alien', } // good const superman = { type: 'alien', } 3.4 创建有动态属性名的对象时，使用可被计算的属性名称。 为什么？因为这样可以让你在一个地方定义所有的对象属性。 function getKey(k) { return `a key named ${k}` } // bad const obj = { id: 5, name: 'San Francisco' } obj[getKey('enabled')] = true // good const obj = { id: 5, name: 'San Francisco', [getKey('enabled')]: true } 3.5 使用对象方法的简写。 // bad const atom = { value: 1, addValue: function (value) { return atom.value + value } }; // good const atom = { value: 1, addValue(value) { return atom.value + value }, } 3.6 使用对象属性值的简写。 为什么？因为这样更短更有描述性。 const lukeSkywalker = 'Luke Skywalker' // bad const obj = { lukeSkywalker: lukeSkywalker, } // good const obj = { lukeSkywalker } 3.7 在对象属性声明前把简写的属性分组。 为什么？因为这样能清楚地看出哪些属性使用了简写。 const anakinSkywalker = 'Anakin Skywalker' const lukeSkywalker = 'Luke Skywalker' // bad const obj = { episodeOne: 1, twoJedisWalkIntoACantina: 2, lukeSkywalker, episodeThree: 3, mayTheFourth: 4, anakinSkywalker } // good const obj = { lukeSkywalker, anakinSkywalker, episodeOne: 1, twoJedisWalkIntoACantina: 2, episodeThree: 3, mayTheFourth: 4 } ⬆ 返回目录 数组 4.1 使用字面值创建数组。 // bad const items = new Array(); // good const items = []; 4.2 向数组添加元素时使用 Arrary#push 替代直接赋值。 const someStack = [] // bad someStack[someStack.length] = 'abracadabra' // good someStack.push('abracadabra') 4.3 使用拓展运算符 ... 复制数组。 // bad const len = items.length const itemsCopy = [] let i for (i = 0; i 4.4 使用 Array#from 把一个类数组对象转换成数组。 const foo = document.querySelectorAll('.foo') const nodes = Array.from(foo) ⬆ 返回目录 解构 5.1 使用解构存取和使用多属性对象。 为什么？因为解构能减少临时引用属性。 // bad function getFullName(user) { const firstName = user.firstName const lastName = user.lastName return `${firstName} ${lastName}` } // good function getFullName(obj) { const { firstName, lastName } = obj return `${firstName} ${lastName}` } // best function getFullName({ firstName, lastName }) { return `${firstName} ${lastName}` } 5.2 对数组使用解构赋值。 const arr = [1, 2, 3, 4] // bad const first = arr[0] const second = arr[1] // good const [first, second] = arr 5.3 需要回传多个值时，使用对象解构，而不是数组解构。 为什么？增加属性或者改变排序不会改变调用时的位置。 // bad function processInput(input) { // then a miracle occurs return [left, right, top, bottom]; } // 调用时需要考虑回调数据的顺序。 const [left, __, top] = processInput(input); // good function processInput(input) { // then a miracle occurs return { left, right, top, bottom }; } // 调用时只选择需要的数据 const { left, right } = processInput(input); ⬆ 返回目录 字符串 6.1 字符串使用单引号 '' 。 // bad const name = \"Capt. Janeway\" // good const name = 'Capt. Janeway' 6.2 字符串超过 80 个字节应该使用字符串连接号换行。 6.3 注：过度使用字串连接符号可能会对性能造成影响。jsPerf 和 讨论. // bad const errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.' // bad const errorMessage = 'This is a super long error that was thrown because \\ of Batman. When you stop to think about how Batman had anything to do \\ with this, you would get nowhere \\ fast.' // good const errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.' 6.4 程序化生成字符串时，使用模板字符串代替字符串连接。 为什么？模板字符串更为简洁，更具可读性。 // bad function sayHi(name) { return 'How are you, ' + name + '?'; } // bad function sayHi(name) { return ['How are you, ', name, '?'].join(); } // good function sayHi(name) { return `How are you, ${name}?`; } ⬆ 返回目录 函数 7.1 使用函数声明代替函数表达式。 为什么？因为函数声明是可命名的，所以他们在调用栈中更容易被识别。此外，函数声明会把整个函数提升（hoisted），而函数表达式只会把函数的引用变量名提升。这条规则使得箭头函数可以取代函数表达式。 // bad const foo = function () { }; // good function foo() { } 7.2 函数表达式: // 立即调用的函数表达式 (IIFE) (() => { console.log('Welcome to the Internet. Please follow me.'); })(); 7.3 注意:永远不要在一个非函数代码块（if、while 等）中声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但它们的解析表现不一致。 7.4 注意: ECMA-262 把 block 定义为一组语句。函数声明不是语句。阅读 ECMA-262 关于这个问题的说明。 // bad if (currentUser) { function test() { console.log('Nope.'); } } // good let test; if (currentUser) { test = () => { console.log('Yup.'); }; } 7.5 永远不要把参数命名为 arguments。这将取代原来函数作用域内的 arguments 对象。 // bad function nope(name, options, arguments) { // ...stuff... } // good function yup(name, options, args) { // ...stuff... } 7.6 不要使用 arguments。可以选择 rest 语法 ... 替代。 为什么？使用 ... 能明确你要传入的参数。另外 rest 参数是一个真正的数组，而 arguments 是一个类数组。 // bad function concatenateAll() { const args = Array.prototype.slice.call(arguments); return args.join('') } // good function concatenateAll(...args) { return args.join('') } 7.7 直接给函数的参数指定默认值，不要使用一个变化的函数参数。 // really bad function handleThings(opts) { // 不！我们不应该改变函数参数。 // 更加糟糕: 如果参数 opts 是 false 的话，它就会被设定为一个对象。 // 但这样的写法会造成一些 Bugs。 //（译注：例如当 opts 被赋值为空字符串，opts 仍然会被下一行代码设定为一个空对象。） opts = opts || {}; // ... } // still bad function handleThings(opts) { if (opts === void 0) { opts = {}; } // ... } // good function handleThings(opts = {}) { // ... } 7.8 直接给函数参数赋值时需要避免副作用。 为什么？因为这样的写法让人感到很困惑。 var b = 1; // bad function count(a = b++) { console.log(a); } count(); // 1 count(); // 2 count(3); // 3 count(); // 3 ⬆ 返回目录 箭头函数 8.1 当你必须使用函数表达式（或传递一个匿名函数）时，使用箭头函数符号。 为什么?因为箭头函数创造了新的一个 this 执行环境（译注：参考 Arrow functions - JavaScript | MDN 和 ES6 arrow functions, syntax and lexical scoping），通常情况下都能满足你的需求，而且这样的写法更为简洁。 为什么不？如果你有一个相当复杂的函数，你或许可以把逻辑部分转移到一个函数声明上。 // bad [1, 2, 3].map(function (x) { return x * x }) // good [1, 2, 3].map((x) => { return x * x }) 8.2 如果一个函数适合用一行写出并且只有一个参数，那就把花括号、圆括号和 return 都省略掉。如果不是，那就不要省略。 为什么？语法糖。在链式调用中可读性很高。 为什么不？当你打算回传一个对象的时候。 // good [1, 2, 3].map(x => x * x) // good [1, 2, 3].reduce((total, n) => { return total + n }, 0) ⬆ 返回目录 构造器 9.1 总是使用 class。避免直接操作 prototype 。 为什么? 因为 class 语法更为简洁更易读。 // bad function Queue(contents = []) { this._queue = [...contents] } Queue.prototype.pop = function() { const value = this._queue[0] this._queue.splice(0, 1) return value } // good class Queue { constructor(contents = []) { this._queue = [...contents] } pop() { const value = this._queue[0] this._queue.splice(0, 1) return value } } 9.2 使用 extends 继承。 为什么？因为 extends 是一个内建的原型继承方法并且不会破坏 instanceof。 // bad const inherits = require('inherits') function PeekableQueue(contents) { Queue.apply(this, contents) } inherits(PeekableQueue, Queue) PeekableQueue.prototype.peek = function() { return this._queue[0] } // good class PeekableQueue extends Queue { peek() { return this._queue[0]; } } 9.3 方法可以返回 this 来帮助链式调用。 // bad Jedi.prototype.jump = function() { this.jumping = true return true }; Jedi.prototype.setHeight = function(height) { this.height = height; }; const luke = new Jedi() luke.jump() // => true luke.setHeight(20) // => undefined // good class Jedi { jump() { this.jumping = true return this } setHeight(height) { this.height = height return this } } const luke = new Jedi() luke.jump().setHeight(20) 9.4 可以写一个自定义的 toString() 方法，但要确保它能正常运行并且不会引起副作用。 class Jedi { constructor(options = {}) { this.name = options.name || 'no name' } getName() { return this.name; } toString() { return `Jedi - ${this.getName()}` } } ⬆ 返回目录 模块 10.1 总是使用模组 (import/export) 而不是其他非标准模块系统。你可以编译为你喜欢的模块系统。 为什么？模块就是未来，让我们开始迈向未来吧。 // bad const AirbnbStyleGuide = require('./AirbnbStyleGuide') module.exports = AirbnbStyleGuide.es6 // ok import AirbnbStyleGuide from './AirbnbStyleGuide' export default AirbnbStyleGuide.es6 // best import { es6 } from './AirbnbStyleGuide' export default es6 10.2 不要使用通配符 import。 为什么？这样能确保你只有一个默认 export。 // bad import * as AirbnbStyleGuide from './AirbnbStyleGuide' // good import AirbnbStyleGuide from './AirbnbStyleGuide' 10.3 不要从 import 中直接 export。 为什么？虽然一行代码简洁明了，但让 import 和 export 各司其职让事情能保持一致。 // bad // filename es6.js export { es6 as default } from './airbnbStyleGuide' // good // filename es6.js import { es6 } from './AirbnbStyleGuide' export default es6 ⬆ 返回目录 Iterators and Generators 11.1 不要使用 iterators。使用高阶函数例如 map() 和 reduce() 替代 for-of。 为什么？这加强了我们不变的规则。处理纯函数的回调值更易读，这比它带来的副作用更重要。 const numbers = [1, 2, 3, 4, 5] // bad let sum = 0 for (let num of numbers) { sum += num } sum === 15 // good let sum = 0 numbers.forEach((num) => sum += num) sum === 15 // best (use the functional force) const sum = numbers.reduce((total, num) => total + num, 0) sum === 15 11.2 现在还不要使用 generators。 为什么？因为它们现在还没法很好地编译到 ES5。 (译者注：目前(2016/03) Chrome 和 Node.js 的稳定版本都已支持 generators) ⬆ 返回目录 属性 12.1 使用 . 来访问对象的属性。 const luke = { jedi: true, age: 28 } // bad const isJedi = luke['jedi'] // good const isJedi = luke.jedi 12.2 当通过变量访问属性时使用中括号 []。 const luke = { jedi: true, age: 28 }; function getProp(prop) { return luke[prop] } const isJedi = getProp('jedi') ⬆ 返回目录 变量 13.1 一直使用 const 来声明变量，如果不这样做就会产生全局变量。我们需要避免全局命名空间的污染。地球队长已经警告过我们了。（译注：全局，global 亦有全球的意思。地球队长的责任是保卫地球环境，所以他警告我们不要造成「全球」污染。） // bad superPower = new SuperPower(); // good const superPower = new SuperPower(); 13.2 使用 const 声明每一个变量。 为什么？增加新变量将变的更加容易，而且你永远不用再担心调换错 ; 跟 ,。 // bad const items = getItems(), goSportsTeam = true, dragonball = 'z' // bad // (compare to above, and try to spot the mistake) const items = getItems(), goSportsTeam = true dragonball = 'z' // good const items = getItems() const goSportsTeam = true const dragonball = 'z' 13.3 将所有的 const 和 let 分组 为什么？当你需要把已赋值变量赋值给未赋值变量时非常有用。 // bad let i, len, dragonball, items = getItems(), goSportsTeam = true // bad let i; const items = getItems() let dragonball const goSportsTeam = true let len // good const goSportsTeam = true const items = getItems() let dragonball let i let length 13.4 在你需要的地方给变量赋值，但请把它们放在一个合理的位置。 为什么？let 和 const 是块级作用域而不是函数作用域。 // good function() { test(); console.log('doing stuff..'); //..other stuff.. const name = getName(); if (name === 'test') { return false; } return name; } // bad - unnecessary function call function(hasName) { const name = getName(); if (!hasName) { return false; } this.setFirstName(name); return true; } // good function(hasName) { if (!hasName) { return false; } const name = getName(); this.setFirstName(name); return true; } ⬆ 返回目录 Hoisting 14.1 var 声明会被提升至该作用域的顶部，但它们赋值不会提升。let 和 const 被赋予了一种称为「暂时性死区（Temporal Dead Zones, TDZ）」的概念。这对于了解为什么 type of 不再安全相当重要。 // 我们知道这样运行不了 // （假设 notDefined 不是全局变量） function example() { console.log(notDefined) // => throws a ReferenceError } // 由于变量提升的原因， // 在引用变量后再声明变量是可以运行的。 // 注：变量的赋值 `true` 不会被提升。 function example() { console.log(declaredButNotAssigned) // => undefined var declaredButNotAssigned = true } // 编译器会把函数声明提升到作用域的顶层， // 这意味着我们的例子可以改写成这样： function example() { let declaredButNotAssigned console.log(declaredButNotAssigned) // => undefined declaredButNotAssigned = true } // 使用 const 和 let function example() { console.log(declaredButNotAssigned) // => throws a ReferenceError console.log(typeof declaredButNotAssigned) // => throws a ReferenceError const declaredButNotAssigned = true } 14.2 匿名函数表达式的变量名会被提升，但函数内容并不会。 function example() { console.log(anonymous) // => undefined anonymous() // => TypeError anonymous is not a function var anonymous = function() { console.log('anonymous function expression') } } 14.3 命名的函数表达式的变量名会被提升，但函数名和函数函数内容并不会。 function example() { console.log(named) // => undefined named() // => TypeError named is not a function superPower() // => ReferenceError superPower is not defined var named = function superPower() { console.log('Flying'); }; } // the same is true when the function name // is the same as the variable name. function example() { console.log(named); // => undefined named(); // => TypeError named is not a function var named = function named() { console.log('named'); } } 14.4 函数声明的名称和函数体都会被提升。 function example() { superPower(); // => Flying function superPower() { console.log('Flying') } } 想了解更多信息，参考 Ben Cherry 的 JavaScript Scoping & Hoisting。 ⬆ 返回目录 比较运算符 & 等号 15.1 优先使用 === 和 !== 而不是 == 和 !=. 15.2 条件表达式例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵守下面的规则： 对象 被计算为 true Undefined 被计算为 false Null 被计算为 false 布尔值 被计算为 布尔的值 数字 如果是 +0、-0、或 NaN 被计算为 false, 否则为 true 字符串 如果是空字符串 '' 被计算为 false，否则为 true if ([0]) { // true // An array is an object, objects evaluate to true } 15.3 使用简写。 // bad if (name !== '') { // ...stuff... } // good if (name) { // ...stuff... } // bad if (collection.length > 0) { // ...stuff... } // good if (collection.length) { // ...stuff... } 15.4 想了解更多信息，参考 Angus Croll 的 Truth Equality and JavaScript。 ⬆ 返回目录 代码块 16.1 使用大括号包裹所有的多行代码块。 // bad if (test) return false; // good if (test) return false; // good if (test) { return false; } // bad function() { return false; } // good function() { return false; } 16.2 如果通过 if 和 else 使用多行代码块，把 else 放在 if 代码块关闭括号的同一行。 // bad if (test) { thing1(); thing2(); } else { thing3(); } // good if (test) { thing1(); thing2(); } else { thing3(); } ⬆ 返回目录 注释 17.1 使用 /** ... */ 作为多行注释。包含描述、指定所有参数和返回值的类型和值。 // bad // make() returns a new element // based on the passed in tag name // // @param {String} tag // @return {Element} element function make(tag) { // ...stuff... return element; } // good /** * make() returns a new element * based on the passed in tag name * * @param {String} tag * @return {Element} element */ function make(tag) { // ...stuff... return element; } 17.2 使用 // 作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行。 // bad const active = true // is current tab // good // is current tab const active = true // bad function getType() { console.log('fetching type...'); // set the default type to 'no type' const type = this._type || 'no type' return type; } // good function getType() { console.log('fetching type...'); // set the default type to 'no type' const type = this._type || 'no type'; return type; } 17.3 给注释增加 FIXME 或 TODO 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。这将有别于常见的注释，因为它们是可操作的。使用 FIXME -- need to figure this out 或者 TODO -- need to implement。 17.4 使用 // FIXME: 标注问题。 class Calculator { constructor() { // FIXME: shouldn't use a global here total = 0; } } 17.5 使用 // TODO: 标注问题的解决方式。 class Calculator { constructor() { // TODO: total should be configurable by an options param this.total = 0; } } ⬆ 返回目录 空白 18.1 使用 2 个空格作为缩进。 // bad function() { ∙∙∙∙const name } // bad function() { ∙const name } // good function() { ∙∙const name } 18.2 在花括号前放一个空格。 // bad function test(){ console.log('test') } // good function test() { console.log('test') } // bad dog.set('attr',{ age: '1 year', breed: 'Bernese Mountain Dog' }) // good dog.set('attr', { age: '1 year', breed: 'Bernese Mountain Dog' }) 18.3 在控制语句（if、while 等）的小括号前放一个空格。在函数调用及声明中，不在函数的参数列表前加空格。 // bad if(isJedi) { fight () } // good if (isJedi) { fight() } // bad function fight () { console.log ('Swooosh!') } // good function fight() { console.log('Swooosh!') } 18.4 使用空格把运算符隔开。 // bad const x=y+5 // good const x = y + 5 18.5 在文件末尾插入一个空行。 // bad (function(global) { // ...stuff... })(this) // bad (function(global) { // ...stuff... })(this)↵ ↵ // good (function(global) { // ...stuff... })(this)↵ 18.5 在使用长方法链时进行缩进。使用前面的点 . 强调这是方法调用而不是新语句。 // bad $('#items').find('.selected').highlight().end().find('.open').updateCount() // bad $('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount() // good $('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount() // bad const leds = stage.selectAll('.led').data(data).enter().append('svg:svg').class('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led); // good const leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .classed('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led); 18.6 在块末和新语句前插入空行。 // bad if (foo) { return bar } return baz // good if (foo) { return bar } return baz // bad const obj = { foo() { }, bar() { }, }; return obj; // good const obj = { foo() { }, bar() { }, }; return obj; ⬆ 返回目录 逗号 19.1 行首逗号：不需要。 // bad const story = [ once , upon , aTime ]; // good const story = [ once, upon, aTime ] // bad const hero = { firstName: 'Ada' , lastName: 'Lovelace' , birthYear: 1815 , superPower: 'computers' }; // good const hero = { firstName: 'Ada', lastName: 'Lovelace', birthYear: 1815, superPower: 'computers' }; ⬆ 返回目录 类型转换 21.1 在语句开始时执行类型转换。 21.2 字符串： // => this.reviewScore = 9; // bad const totalScore = this.reviewScore + ''; // good const totalScore = String(this.reviewScore); 21.3 对数字使用 parseInt 转换，并带上类型转换的基数。 const inputValue = '4'; // bad const val = new Number(inputValue); // bad const val = +inputValue; // bad const val = inputValue >> 0; // bad const val = parseInt(inputValue); // good const val = Number(inputValue); // good const val = parseInt(inputValue, 10); 21.4 布尔: const age = 0; // bad const hasAge = new Boolean(age); // good const hasAge = Boolean(age); // good const hasAge = !!age; ⬆ 返回目录 命名规则 22.1 避免单字母命名。命名应具备描述性。 // bad function q() { // ...stuff... } // good function query() { // ..stuff.. } 22.2 使用驼峰式命名对象、函数和实例。 // bad const OBJEcttsssss = {}; const this_is_my_object = {}; function c() {} // good const thisIsMyObject = {}; function thisIsMyFunction() {} 22.3 使用帕斯卡式命名构造函数或类。 // bad function user(options) { this.name = options.name; } const bad = new user({ name: 'nope', }); // good class User { constructor(options) { this.name = options.name; } } const good = new User({ name: 'yup', }); 22.4 使用下划线 _ 开头命名私有属性。 // bad this.__firstName__ = 'Panda'; this.firstName_ = 'Panda'; // good this._firstName = 'Panda'; 22.5 别保存 this 的引用。使用箭头函数或 Function#bind。 // bad function foo() { const self = this; return function() { console.log(self); }; } // bad function foo() { const that = this; return function() { console.log(that); }; } // good function foo() { return () => { console.log(this); }; } 22.6 如果你的文件只输出一个类，那你的文件名必须和类名完全保持一致。 // file contents class CheckBox { // ... } export default CheckBox; // in some other file // bad import CheckBox from './checkBox'; // bad import CheckBox from './check_box'; // good import CheckBox from './CheckBox'; 22.7 当你导出默认的函数时使用驼峰式命名。你的文件名必须和函数名完全保持一致。 function makeStyleGuide() { } export default makeStyleGuide; 22.8 当你导出单例、函数库、空对象时使用帕斯卡式命名。 const AirbnbStyleGuide = { es6: { } }; export default AirbnbStyleGuide; ⬆ 返回目录 存取器 23.1 属性的存取函数不是必须的。 23.2 如果你需要存取函数时使用 getVal() 和 setVal('hello')。 // bad dragon.age(); // good dragon.getAge(); // bad dragon.age(25); // good dragon.setAge(25); 23.3 如果属性是布尔值，使用 isVal() 或 hasVal()。 // bad if (!dragon.age()) { return false; } // good if (!dragon.hasAge()) { return false; } 23.4 创建 get() 和 set() 函数是可以的，但要保持一致。 class Jedi { constructor(options = {}) { const lightsaber = options.lightsaber || 'blue'; this.set('lightsaber', lightsaber); } set(key, val) { this[key] = val; } get(key) { return this[key]; } } ⬆ 返回目录 事件 24.1 当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。例如，不好的写法： // bad $(this).trigger('listingUpdated', listing.id); ... $(this).on('listingUpdated', function(e, listingId) { // do something with listingId }); 更好的写法： // good $(this).trigger('listingUpdated', { listingId : listing.id }); ... $(this).on('listingUpdated', function(e, data) { // do something with data.listingId }); ⬆ 返回目录 jQuery 25.1 使用 $ 作为存储 jQuery 对象的变量名前缀。 // bad const sidebar = $('.sidebar') // good const $sidebar = $('.sidebar') 25.2 缓存 jQuery 查询。 // bad function setSidebar() { $('.sidebar').hide() // ...stuff... $('.sidebar').css({ 'background-color': 'pink' }); } // good function setSidebar() { const $sidebar = $('.sidebar'); $sidebar.hide(); // ...stuff... $sidebar.css({ 'background-color': 'pink' }); } 25.3 对 DOM 查询使用层叠 $('.sidebar ul') 或 父元素 > 子元素 $('.sidebar > ul')。 jsPerf 25.4 对有作用域的 jQuery 对象查询使用 find。 // bad $('ul', '.sidebar').hide(); // bad $('.sidebar').find('ul').hide(); // good $('.sidebar ul').hide(); // good $('.sidebar > ul').hide(); // good $sidebar.find('ul').hide(); ⬆ 返回目录 Copyright © zhangxiaofeng 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-12 09:55:09 "}}